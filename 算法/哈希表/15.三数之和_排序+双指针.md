# 15.三数之和

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

[梦破碎的地方！| LeetCode：15.三数之和_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1GW4y127qo)



这题是究极长痛，在前面的题中唯一一个用暴力法难度也很大的题，这题也是面试中非常常见的一道题，必须掌握。

问题的关键是**如何去重**，而去重的思路有点太难想了。

再者，就算暴力做，时间复杂度最起码是O(n^3)，时间有点太长了。

并且，这题不同于之前的两数之和和四数之和Ⅱ，这题并不适合用哈希法，用哈希法最后还是要去重，而且比不用哈希法还慢，有点多此一举。



## 1. 排序+双指针

### 思路

但凡你尝试过暴力法，你就可以了解到两个课题：

1. 题目要求去掉重复解，必须想到一个可行的去重方案
2. 时间复杂度比较大，如何降低时间复杂度

只有把这两个问题解决了，这题才能做出来。

首先我们要想清楚：存在重复解的本质是什么：

1. 下标指向重合（题目不允许三个数的下标两两相同）
2. 数组中存在重复的元素，如[-5, -3, 6, 0, -3, 6, -5, 5]，这种情况会造成非常多的重复解

造成麻烦的地方在于，我们没有办法有效的定位到这些重复的元素，那么什么方法可以有效地让这些元素都待在一起呢？

**排序**和**哈希法**

但是哈希法如果是将值作为key，出现次数作为value，丢失了下标的信息，除了使用其他办法来解决第一个问题外，去重办法仍未可知。

如果是在去重前将数组排序的话，那么重复的元素会待在一起，那么在我们第一次获取到某个解的时候，下次遇到重复的元素，是不是就可以跳过它了呢？**排序让这个数组变得可控，为去重提供了便利**，并且还提供了另一个有效信息，这是我们能够获得解的关键：**升序排序后，在数组左边的值最小，在数组右边的值最大。**那么利用这个信息，当a + b + c > 0的时候，我们应该做什么操作，反之<0的时候呢？

现在，去重的思路已经有了，那么时间复杂度又该怎么降低呢？

**空间换取时间**、又或者是将两层循环逻辑优化为一层的**双指针**法

空间换时间的做法目前我没有什么想法，双指针法是比较常用的降时间复杂度的方法，如果正确使用双指针，可以将O(n ^ 3)降为O(n ^ 2)，符合我们的预期。那么应该怎么使用双指针呢？

在上面，我们谈到排序后获得了一个关键的信息，在这里我们就可以用到了。假如我们先使用第一层循环遍历a，然后对b和c的取值使用双指针法在同一个循环内完成操作，是否可行呢？

在第二层循环的时候，a的取值是不会变的，直到第二层循环结束，a才会指向下一个下标继续循环。所以在第二个循环，a固定，b和c的取值是变化的，我们不妨将b的下标初始化为a的下标的下一个位置，将c的下标位置放在数组的末尾（双指针）。

1. 当 a + b + c > 0的时候
   - 此时三数之和比0大，因为a在第二个循环内是固定不变的，所以要么就是b的值太大了，或者是c的值太大了，排序之后，b肯定是小于c的，所以改变c就有机会让三数之和变小，**怎么让c变小呢，指针左移**。
2. 当 a + b + c < 0的时候
   - 同理a不变，所以要么是b的值小了，或者是c的值小了，b比c小，此时将c往右移动虽然可以让三数之和变大，但由于c的位置一开始就在数组的最右边，如果移动c非常容易导致溢出。而让b向右移同样可以让三数之和变大，所以这种情况**b指针右移**即可。
3. 当 a + b + c = 0的时候、
   - 在这时，我们就可以获得解了，然而获得解之后还没完。由于有重复的值，为了防止下次进入该情况时存在重复解，这时候我们需要进行去重操作：如果指针下个移动的位置和当前位置的值相同，那么就跳过（指针移动），直到不相等为止。
   - 去重结束后，头尾两个指针需向下个位置移动，否则会进入死循环。

这道题目主要的思路就是这样，大体上就是这么写的，但是不得不说，这道题具体写下来，细节也非常的多，所以这道题非常有挑战性，虽然只是中等难度，要考虑的东西已经非常多了，难怪是面试常客，真的不给活路（悲）

### 细节处理

1. 在第一层循环每一次进入，我们都可以对num[i]的进行判断。如果它大于0，那么就没有必要再循环下去了——因为排序过后，第一个数大于0，那么后面两个数的取值永远都不可能让三数之和为0。但是**等于0的情况，还是要继续循环**，因为还要考虑数组存在{0, 0, 0}的情况，这样的解也符合题意
2. 对第一个数的去重操作，为什么是 nums[i] == nums[i-1] 而不是 nums[i] == nums[i+1]？
   - 在这题里，我们的思路一直都是，**先获得解之后，再去重**，这个想法非常重要。我们必须确保先获得解，再去重，如果我们还没有找到当前位置的值的某个解，就**贸然向下移动的话，很容易漏掉解**。比如这个数组[-1, -1, 0, 1, 2]，当a = 0，b = 1，c = 2时，即解{-1, -1, 2}，假如你在a = 0的时候使用 nums[i] == nums[i+1] 来去重，就直接把a = 0的获得解的可能性跳过了，这时a = 1，后续已经没有办法获得{-1, -1, 2}这个解了。
   - 所以，我们应该先给它一次机会，让他先试一次循环，看看能不能找到解，再执行去重操作，这就是为什么我们使用 nums[i] == nums[i-1] 去重的原因。
3. 第二个循环的边界性问题，为什么是 left < right 而不是 left <= right？
   - 假设left == right，那么就意味着b和c的下标相等，然而**题目不允许下标指向重合**，所以不行
4. 一开始做的时候，有可能会把第二个数和第三个数的去重操作放到else的外面来执行，这是不行的。还是那个思路：**先获得解，再去重**。如果放到外面的话，假设b和c第一次遇到这种值还没试能不能凑出一个解，就直接跳过了。所以这个去重操作肯定是放在else里面的，等到确确实实是获得解了，再去重，去完重再移动指针去寻找下一种组合。

### 代码实现

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        int n = nums.size();
        int left = 1;
        int right = n - 1;
        
        sort(nums.begin(), nums.end()); // 进循环之前必须先排序
        
        for(int i = 0; i<n; i++) {
            // 如果num[i]大于等于0，那么三数之和必不为0；不行，只能是大于0，因为还要考虑{0, 0, 0}这种情况
            if(nums[i] > 0) { 
                return ans;
            }
            // 第一个数的去重操作，不要忘记写i>0，会溢出
            if(i>0 && nums[i] == nums[i-1]) {
                continue;
            }
            // 记得每次i变动后，left和right也要重新初始化
            left = i + 1;
            right = n - 1;
            // 为什么不可以left <= right？因为题目说了三个数的下标都不相等
            while(left < right) { // 在这个循环内，第一个数即nums[i]已经固定，所以能变的只有left和right
                // 三数之和大于0，那么一定是right的值大了，需要变小才有机会为0
                if(nums[i] + nums[left] + nums[right] > 0) { 
                    right--;
                }
                // 三数之和小于0，那么一定是left的值小了，需要变大才有机会为0
                else if(nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } 
                // 为什么是放在这里进行去重而不是else结束的下面？为了防止得到结果后left++和right--后又获得了相同的值
                else {
                    ans.push_back({nums[i], nums[left], nums[right]}); // 得到一个解
                    // 开始第二个数和第三个数的去重操作
                    while(left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while(left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    // 得到答案后也要操作指针，否则会陷入死循环
                    left++;
                    right--;
                }
            }
        }
        return ans;
    }
};
```

时间复杂度为O(n^2 + nlogn)，或者是O(n^2)。

从结果上来说，这题虽然很难，但是我总算是在卡尔的帮助下搞清楚这道题了，与其说是难题让我受挫，不如说搞清楚后面对难题更有信心了，虽然只是中等题。
