# 202.快乐数

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)

这题我没有做出来，两种方法都没有想到，一开始我想着暴力用数组做，却想不到循环跳出的条件，可能是我太懒了，如果我发现n=2这个示例一直算下去会产生数相同然后循环的问题就可能会做了。。。

```c++
happy(2) = 2^2 = 4;
happy(4) = 4^2 = 16; // 循环点
happy(16) = 1^2 + 6^2 = 37;
happy(37) = 3^2 + 7^2 = 58;
happy(58) = 5^2 + 8^2 = 89;
happy(89) = 8^2 + 9^2 = 145;
happy(145) = 1^2 + 4^2 + 5^2 = 42;
happy(42) = 4^2 + 2^2 = 20;
happy(20) = 2^2 + 0^2 = 4;
happy(4) = 4^2 = 16; // 从这里开始就一直在循环了，靠
...
happy(4) = 4^2 = 16;
```

做这种题的时候，应该要把各种情况列出来：

1. 最后可以等于1
2. 会进入循环
3. 可能值会越来越大，最后接近无穷大

第一种情况我们无需验证，示例已经给了，确认是可以的。

第二种情况我们上面对2进行快乐操作（逆天）已经得知存在环的情况。

第三种情况，我们需要验证到底会不会变得无限大，题目中对输入的限制是1 <= n <= 2^31 - 1，n最大有十位数，那么我们每位都取9进行观察：

| 位数 | n          | happy(n) |
| ---- | :--------- | -------- |
| 1    | 9          | 81       |
| 2    | 99         | 162      |
| 3    | 999        | 243      |
| 4    | 9999       | 324      |
| 5    | 99999      | 405      |
| 10   | 9999999999 | 810      |

可以看到在这个范围内，无论n为多大，它的下一个数都会回到三位数内。而在三位数内进行快乐操作，一定会小于243，因为在三位数内999进行快乐操作得到的数最大，为243，所以小于999的数得到的值会小于243。这意味着无论多大的数，进行快乐操作后，都会回到三位数，并且最终数值不会再超过243，而是在243以下的所有数字上循环或者等于1。

所以，第三种情况是不会发生的，我们排除。

分析到这里，基本上我们就可以发现，进行快乐操作，数是会先变大然后再变小然后又变大再变小的，所以存在环的可能性非常大。



## 1. 哈希集合

我们分析完之后，可以得知快乐数结束的条件是遇到1（true）或者出现环，也就是遇到了重复的数字（false）。

那么很自然就可以想到哈希集合了。

```c++
class Solution {
public:
    int getSum(int n) {
        int sum = 0;
        while(n != 0) {
            sum += (n%10) * (n%10); // n%10得到某位上的数字
            n /= 10; // 降位操作
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> hashSet;
        int sum = getSum(n);
        while(hashSet.find(sum) == hashSet.end()) { // 只要发现哈希集合中有与sum相等的数，循环结束
            if(sum == 1) { // 结果为1，返回true
                return true;
            }
            hashSet.insert(sum); // 如果哈希集合中没有发现sum这个数存在，那么就插入到集合中
            sum = getSum(sum); // 进行快乐操作
        }
        return false;
    }
};
```





## 2. 快慢双指针

经过分析，我们发现数值要么等于1，要么存在环。存在环的问题我们可以考虑快慢指针法。和[环形链表Ⅱ](E:\VanSama no note\算法\链表\142.环形链表Ⅱ_哈希表_快慢双指针.md)不同，这里我们不需要考虑入环点这种问题，我们只需要判断快慢指针会不会相遇就可以了，如果可以相遇，那么就是存在环。

关键是怎么表示出快慢呢？我们可以把这个数字的快乐操作过程看做链表（事实上确实是链表的结构），你做一次快乐操作（getNext）就相当于链表中的p = p -> next。那么慢指针移动一次就可以定义为 slow = getNext(slow)，快指针移动一次就可以定义为 fast = getNext(getNext(fast))。

```c++
class Solution {
public:
    int getNext(int n) {
        int sum = 0;
        while(n != 0) {
            sum += (n%10) * (n%10); // n%10得到某位上的数字
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        int slow = n;
        int fast = getNext(n); // 这里为什么不是n，那你想一想，你下面的判断条件支持你一开始就和slow相等吗
        while(fast != 1 && fast != slow) {
            // 这个方法最核心的两行
            slow = getNext(slow); // 一次移动一步
            fast = getNext(getNext(fast)); // 一次移动两步
        }
        return fast == 1; // 这种返回方式也很妙
    }
};
```



