# 冒泡排序

冒泡排序是交换排序中最简单的排序方法，交换排序的特点是在待排序序列中选取两个元素，如果是反序则交换，当反序对都解决了，排序也就完成了。因此冒泡排序的核心思路也是在于**交换**二字。

那么冒泡排序为什么要叫做冒泡排序呢？是因为在冒泡排序中，大的数都会逐渐往上跑，小的数都会往下跑，因此和大泡泡在水上，小泡泡在水下的道理是一样的，所以叫冒泡排序。

> 冒泡排序
>
> 1. 遍历数组，检查相邻的对是否反序，是反序则交换，否则什么也不做。
> 2. 重复步骤1直到排序完成。

算法动画如下：

![动图](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

- 黄色部分是已排序好的部分
- 蓝色是带排序的部分
- 绿色是相邻的待交换对

根据动画，我们可以发现，待排序部分中最大值一定会交换到右边界。因为在待排序部分没有比它更大的了，所以它一定会在能交换的时候交换，直到不能交换为止。那么到什么时候交换不了？当它到右边界的时候。因此一次循环一定可以**至少**缩小一次待排序序列（为什么是至少，因为在交换的时候，有可能刚好把次大的也交换到右边界前一个位置了）。

我们可以初步写出这样的代码：

```c++
void bubbleSort(vector<int>& nums)
{
	for(int i = 0; i<nums.size()-1; i++) // 如果数组长度为n，每次交换都只缩小了一次待排序序列，那么最多n-1次交换循环才能完成排序，因为n-1次交换之后只剩下第一个元素了，第一个元素就不需要做交换了
	{
		for(int j = 0; j<nums.size()-1-i; j++) // 每次交换循环结束，至少会缩小一次待排序序列，因此终止条件是nums.size()-1-i，-1是因为数组长度为n，相邻交换的对有n-1个，因此第一次进入交换循环是nums.size()-1-0。
		{
			if(nums[j] > nums[j+1]) // 相邻对反序判断
			{
				int temp = nums[j];
				nums[j] = nums[j+1];
				nums[j+1] = temp;
			}
		}
	}
}
```

当然这种做法是绝对有优化空间的，我们来看看这么个例子（加粗意为已经排好序）。

- 待排序：50 13 55 97 27 38 49 65
- 第一次：13 50 55 27 38 49 65 **97**
- 第二次：13 50 27 38 49 **55** **65** **97**
- 第三次：13 27 38 49 **50** **55** **65** **97**
- 第四次：**13** **27** **38** **49** **50** **55** **65** **97**

可以发现，在第四次，我们甚至不需要做交换，数组就已经排好序了，而我们按照上面的代码，还需要白白再做3次（共7次）循环判断反序才能结束算法，这样做感觉很亏。

那么按照这个思路，既然在第四次循环开始之前，我们的数组就已经是有序了，那么我们不妨维护一个bool类型的变量isExchange来记录一次循环中有没有发生反序交换操作，如果有，那么就说明数组还不是有序的，如果没有，那么说明数组有序，不需要再循环下去。

代码如下：

```c++
void bubbleSort(vector<int>& nums)
{
	bool isExchange = false; // 记录一次循环是否存在交换
	for(int i = 0; i<nums.size()-1; i++)
	{
		isExchange = false; // 每次循环前都记为false
		for(int j=0; j<nums.size()-i-1; j++)
		{
			if(nums[j] > nums[j+1]) // 相邻对反序判断
			{
				isExchange = true; // 发生交换，记录为true
				int temp = nums[j];
				nums[j] = nums[j+1];
				nums[j+1] = temp;
			}
		}
		if(isExchange == false) // 如果这次循环没有发生交换，那么直接退出循环，算法结束
		{
			break;
		}
	}
}

```

这种优化的思路比较直观，而且对结构没有太大的改变，因此我个人比较喜欢这种写法。

不过还有一种优化思路，效果和这种优化方法差不多。

我们再来看看这个例子：

- 待排序：50 13 55 97 27 38 49 65
- 第一次：13 50 55 27 38 49 65 **97**
- 第二次：13 50 27 38 49 **55** **65** **97**
- 第三次：13 27 38 49 **50** **55** **65** **97**
- 第四次：**13** **27** **38** **49** **50** **55** **65** **97**

我们上面说过，一次循环一定可以**至少**缩小一次待排序序列的右边界，但是这个至少是不确定的。
比如这里的例子，我们可以换个思路来思考：
第一次，我们只把待排序序列的右边界缩小了一次；
第二次，我们把待排序序列的右边界缩小的两次；
第三次，我们把待排序序列的右边界缩小了一次；
第四次，我们把待排序序列的右边界直接缩小到了与左边界相等，此时数组有序，因此就没有第五次了。

那么，我们能否通过右边界的位置来控制交换循环的次数呢？当 待排序序列右边界 - 左边界 > 0 的时候，说明还存在未排序的部分；当 待排序序列右边界 - 左边界 = 0 的时候，说明当前数组已经有序，退出循环。

```c++
void bubbleSort(vector<int>& nums)
{
	int right = nums.size()-1; // 记录待排序序列的右边界，待排序序列为[0, right]
	while(right > 0)
	{
		int bound = right; // 记录上一次的右边界
		right = 0; // 用来更新这一次循环结束后的右边界
		for(int j = 0; j<bound; j++) // 终止条件为上一次循环划分好的右边界bound
		{
			if(nums[j] > nums[j+1]) // 相邻对反序判断
			{
				int temp = nums[j];
				nums[j] = nums[j+1];
				nums[j+1] = temp;
				right = j; // 如果发生交换的话，这次循环最后一次交换j+1的位置一定是排序好的元素，right是待排序序列的右边界，因此是 right = j 而不是 right = j + 1
			}
		}
	}
}
```

那么这就是第二种实现方法了，实际上思路也不绕，就是可能一开始很难想到，慢慢就可以想到优化的思路了，一个循序渐进的过程。



对于冒泡排序的稳定性，我们可以很容易的想到，冒泡排序是稳定的排序算法。因为冒泡排序的核心是相邻元素的交换，如果是两个相等的元素，是不会交换的，不会交换就意味着他们两个的相对位置永远都不会变化。

最后我们来讨论一下时间复杂度和空间复杂度。

先说空间复杂度吧，同样，冒泡排序没有涉及到大量的额外空间，是常数级的，因此空间复杂度为O(1)。

再来说说时间复杂度。最好的情况下即输入的数组本身就是一个顺序有序的数组，因此对于优化后的冒泡排序来说只需要执行一次循环判断是否存在交换，即O(n)；最坏的情况下即输入的数组本身是一个逆序有序的数组，因此在每次循环中只有一个元素被交换到了右边界，所以会做n-1次循环，因此在内层循环中，我们会执行(n-1) + (n-2) +...+ 1次，即 n*(n-1)/2次，因此时间复杂度为O(n^2)。那么一般情况下，平均下来O( (O(n) + O(n^2)) /2 ) = O(n ^ 2)，所以一般情况下的时间复杂度也是O(n ^ 2)。



