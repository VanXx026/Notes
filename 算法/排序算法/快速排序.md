# 快速排序

快速排序属于交换排序这一类，是对冒泡排序的改进。因为冒泡排序是相邻的元素交换，要将元素交换到合适的位置，大部分时候都需要做很多次交换操作。而快速排序的交换是跳跃性的，元素的比较和移动从两端向中间进行，根据比较的基准（pivot，轴值）可以让大的值一下移动到后边，让小的值一下就移动到前边，从而减少了交换的操作。

快速排序的基本思想是：选定一个轴值pivot，将待排序序列划分成两部分，让左侧序列均小于轴值pivot，让右侧序列均大于轴值pivot，然后紧接着对左右侧序列重复上述的过程，直到整个待排序序列有序。显然，快速排序是一个递归的过程。

那么，要实现快速排序算法，首先就要解决几个问题。

- 轴值pivot怎么选择？
  怎么选择轴值对算法的实现是有影响的。
  最简单的方法是每次都选取序列的第一个元素。
- 怎么根据轴值pivot将待排序序列划分成两部分？
  划分序列的方法叫做一次划分，也可以叫分区partition。

因此，快速排序对于如何选择轴值pivot也是一门学问，我们先实现最简单的一种：选取序列的第一个元素。

## 1. 轴值pivot选择序列的第一个元素

我们现在的轴值选择的是序列的第一个元素，那么我们怎么利用这个轴值将序列划分成比轴值都小的左序列和比轴值都大的右序列呢？

我们最初的想法应该是，每个元素都应该与轴值进行比较：如果当前元素比轴值小，那么它应该到轴值的左边去；如果当前元素比轴值大，那么它应该到轴值的右边去。这种想法很合理，但是实现起来很麻烦，因为我们选择的轴值是序列的第一个元素，如果有元素比轴值小，我们不得不像直接插入排序那样去挪动元素前的所有元素来腾出一个位置，这种做法没有办法达到我们优化冒泡排序的目的。
既然将小的元素直接插入到轴值的左边去很麻烦，不妨换位思考，既然当前元素比轴值小，那么我们将轴值和当前元素的位置交换一下，这个元素不就在轴值的左边了吗？同理，更大的元素与轴值位置交换，那么这个元素就在轴值的右边了。就这样重复交换，最后轴值的位置就固定了，左侧序列均小于轴值，右侧序列均大于轴值。

思路大概就是这么个思路，其中的细节还是要到代码中解决。

```c++
// 一次划分算法
int partition(vector<int>& nums, int left, int right)
{
	int pivot = left; // 轴值的位置
	while(left < right)
	{
		while(left < right && nums[right] >= nums[pivot]) right--; // 先扫描左侧，直到找到比轴值更小的元素，为什么是更小的元素，因此此时的元素在轴值的右边，在交换的时候，这个更小元素的元素才会在轴值的左边。此时的pivot就是left，left固定不动，因此pivot的范围是[left, right--]
		if(left < right) // 为什么在这里需要做left<right的判断？其实你可以把这个算法看成找轴值在序列中的正确位置的算法，[left, right]就是pivot可能存在的位置，我们通过不断缩小left和right，最后在left=right确定pivot的位置，并同时将左序列和右序列完成。如果此时left<right，说明left=right，pivot的位置已经确定，就没有必要进行if语句中的交换和left++了。
		{
			swap(nums[right], nums[pivot]);
			pivot = right;
			left++; // 这是为了在下一个while语句移动left时不需要重复判断一次nums[left] <= nums[pivot]，因为在这次交换之前，pivot就等于left，因此需要left++避免重复判断一次，这属于优化，其实可以不写的，细节问题。
		}
		while(left < right && nums[left] <= nums[pivot]) left++; // 扫描了左侧之后，再扫描右侧，缩小pivot的范围，找到比pivot更大的元素，此时的pivot就是right，right固定不动，因此pivot的范围就是[left++, right]
		if(left < right) // 同上
		{
			swap(nums[left], nums[pivot]);
			pivot = left;
			right--;
		}
	}
	return pivot;
}

// 快速排序主逻辑
void quickSort(vector<int>& nums, int left, int right)
{
	if(left >= right)
	{
		return;
	}
	int pivot = partition(nums, left, right); // 得到轴值的位置
	quickSort(nums, left, pivot - 1); // 左序列进行快排，因为轴值的位置在一次划分算法中已经确定，所以pivot不参与后续
	quickSort(nums, pivot + 1, right); // 右序列进行快排
}
```

这种做法中，如果将一次划分算法看成根据[left, right]的范围来确定pivot轴值的位置还挺好理解的，毕竟要想要轴值右边是更大的值，那么遇到了更大的值就要将right右移；想要轴值左边是更小的值，那么遇到的更小的值就要将left右移，最后left = right确定了pivot的位置的同时，自然而然地左序列和右序列就确定好了。

那么我们来看看快排的稳定性。先说结论，不稳定。
还是那个序列{2, 2 *, 1}，我们以2作为轴值，首先1和2进行交换，序列变成{1, 2 *, 2}，此时左序列为{1, 2 *}，右序列为空。左序列继续做一次划分算法，以1为轴值，最后得右序列{2 *}，左序列为空。因此最后快速排序算法的结果是{1, 2 *, 2}。可以发现执行快速排序算法后，相同元素的相对位置改变了，因此快速排序算法是不稳定的排序算法。

最吓人的一集，我们来看看这种做法的快速排序的时间复杂度和空间复杂度。

### 最好情况下的时间复杂度和空间复杂度

最好的情况下，序列应每次都能划分为长度相等的左右序列，因为只有这样可以最大程度的缩短每次递归调用时传入的序列长度，从而减少计算的次数。
最好情况下的快速排序算法的递归调用树如下，其中的节点值表示序列的长度，严格来说节点值为1的都应该为空。

<img src="C:\Users\Van\AppData\Roaming\Typora\typora-user-images\image-20230223171318398.png" alt="image-20230223171318398" style="zoom: 80%;" />

- 快速排序有三个步骤，首先是一次划分算法，然后是两次递归调用。
- 先说一次划分算法，一次划分算法的目的是为了确定轴值的同时划分左右序列，只要是为了确定轴值，最后[left, right]区间一定会变成left = right，也就是left，right向中间扫描，这个过程一定会做n次。并且在一次划分算法中，扫描和交换是并列的，并不是嵌套关系，因此无论交换多少次，最后一次划分算法的时间复杂度都一定是O(n)。
- 再说说两次的递归调用，如果以规模n完成整个快速排序耗时为T(n)，那么以规模n/2完成快速排序的耗时就为T(n/2)。因此这两个递归调用的耗时都是T(n/2)。
- 因为这三个步骤是并列关系，因此加算，得T(n) = T(n/2) + T(n/2) + n。
  - T(n) = 2**T(n/2)** + n
  - T(n) = 2( **2T(n/4) + n/2** ) + n = 4T(n/4) + 2n
  - T(n) = 4( 2T(n/8) + n/4) + 2n = 8T(n/8) + 3n
  - 令k表示8，那么8 = k，3 = log2k
  - 当k趋于n时，
  - T(n) = nT(1) + n * log2n = O(nlogn)

所以在最好的情况下，快速排序的时间复杂度为O(nlogn)。

在快速排序算法中，每次递归所使用到的空间都是常数级的，又因为最好情况下的递归深度为log2n，因此空间复杂度为O(logn)。

### 最坏情况下的时间复杂度和空间复杂度

最坏的情况下，待排序序列是正序或逆序，导致每次划分都只能划分出一个左序列或者一个右序列，另外一个序列为空。也就是说，每次递归调用只能缩短一个长度，因此效率就低了。

最坏情况下的快速排序算法的递归调用树如下，其中的节点值表示序列的长度，严格来说节点值为1的都应该为空。

![image-20230223171420529](C:\Users\Van\AppData\Roaming\Typora\typora-user-images\image-20230223171420529.png)

- 在一次划分算法中，无论是正序还是逆序，都只需要做n-1次扫描，就可以让left = right，并确定pivot的位置，这种情况下不会涉及到交换操作。

- 再说说两次的递归调用，如果以规模n完成整个快速排序耗时为T(n)，那么以规模n-1完成快速排序的耗时就为T(n-1)，因为其中一个序列为空，因此另外一个递归调用的耗时是常数级的，记为T(1) = 1。
- 有 T(n) = T(n -1) + 1 + n - 1
  - T(n) = T(n - 1) + n
  - T(n) = T(n - 2) + n + n-1
  - T(n) = T(n - 3) + n + n-2 + n-3
  - ...
  - T(n) = T(1) + n + n-1 + n-2 + ... + 1
  - T(n) = 1 + n(n-1)/2 = O(n ^ 2)

所以在最坏的情况下，快速排序算法的时间复杂度为O(n ^ 2)。

在快速排序算法中，每次递归所使用到的空间都是常数级的，又因为最坏情况下的递归深度为n-1，因此空间复杂度为O(n)。

### 平均情况下的时间复杂度和空间复杂度

通过对最好和最坏的情况分析，我们发现如果一开始选择的轴值在序列排序后的位置越靠近中间，情况就越好，越靠近边缘（越小或越大），情况就越坏。因此选择的轴值区间在左中或者右中的位置，情况就比较平均。

| 轴值选择情况 | 1 坏     | 2        | 3 好     | 4        | 5 坏     |
| ------------ | -------- | -------- | -------- | -------- | -------- |
| 时间复杂度   | O(n ^ 2) | O(nlogn) | O(nlogn) | O(nlogn) | O(n ^ 2) |
| 空间复杂度   | O(n)     | O(logn)  | O(logn)  | O(logn)  | O(n)     |

平均情况下，设轴值是待排序序列的第k小(1<=k<=n)记录，则有 T(n) = T(n - k) + T(k - 1) + n = O(nlog2n)。



## 2. 轴值随机选择序列中的一个元素

我一开始以为有多难呢，真没想到啊，是这样随机的，看了代码你就懂了。

```c++
int partition(vector<int>& nums, int left, int right)
{
	int pivot = left;
	while(left < right)
	{
		while(left < right && nums[right] >= nums[pivot]) right--;
		if(left < right)
		{
			swap(nums[right], nums[pivot]);
			pivot = right;
			left++;
		}
		while(left < right && nums[left] <= nums[pivot]) left++;
		if(left < right)
		{
			swap(nums[left], nums[pivot]);
			pivot = left;
			right--;
		}
	}
	return pivot;
}

int randomPartition(vector<int>& nums, int left, int right)
{
	int randomPivot = rand() % (right - left + 1) + left; // 在[left, right]中随机取一个位置作为轴值的位置
	swap(nums[randomPivot], nums[left]); // 将轴值和序列的第一个元素交换，逆天
	return partition(nums, left, right); // 执行普通的一次划分算法（轴值取序列的第一个元素）
}

void quickSort(vector<int>& nums, int left, int right)
{
	if(left >= right)
	{
		return;
	}
	int pivot = randomPartition(nums, left, right); // 调用随机过的一次划分算法
	quickSort(nums, left, pivot - 1);
	quickSort(nums, pivot + 1, right);
}
```

真离谱啊，没想到是随机完之后再和第一个元素交换，那真的牛批。

稳定性、时间复杂度和空间复杂度就不讨论了，上面讲得很清楚了。