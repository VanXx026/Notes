# 堆排序

堆排序也是一种选择排序，它是简单选择排序的一种改进，它主要改进在于减少了元素的比较次数。
简单选择排序在每一轮找最小值的时候，没有把途中的比较结果保存下来，因此元素之间在比较谁最小的时候耗费了很多时间。
堆排序在选出最小值的同时，顺带找到了较小的那些值，减少了比较的次数，从而提高效率。

堆是一种**完全二叉树**，有大根堆和小根堆。
**大根堆**：每个节点的值都**大于等于**它的左右节点的值的完全二叉树。
**小根堆**：每个节点的值都**小于等于**它的左右节点的值的完全二叉树。

在讨论堆排序之前，我们先来讨论一下一个问题：在一棵完全二叉树中，根结点的左右子树都是堆，我们怎么调整才能让这棵完全二叉树变为一个堆？以大根堆为例。
如果要让这颗完全二叉树变成一个大根堆，那么首先根结点一定是最大值，它的左右节点也应该是次大值。已知根结点的左右子树都是大根堆，那么左右子树的根结点在这棵树中一定是最大的两个数，那么我们根结点的值就应该是他们两个中最大的那个节点值，然后交换根结点和节点值更大的那个孩子节点，这样一来，根结点的值就是最大值了。
还没完，因为一开始根结点的值我们是未知的，有可能它的值是整棵树中的最小值也说不定。因此我们还需要判断与根结点交换后的那个节点在以它为根结点的树还是不是大根堆，如果它在那棵树中已经不是最大值了，那么就重复上述的步骤，与孩子中更大的那个节点交换。。。
过程如图所示，**图中根结点的开始编号应该为0**：
<img src="E:\VanSama no note\算法\排序算法\堆调整.jpg" alt="堆调整" style="zoom: 50%;" />

按照我们刚才的思路，堆调整算法如下，在堆排序中，最重要的就是这个堆调整算法（以大根堆为例）：

```c++
void sift(vector<int>& nums, int k, int right)
{
	int i = k; // i：当前要调整的节点
	int j = 2*i+1; // j：当前要调整的节点的左孩子；因为要对齐数组的下标，因此根结点编号为0
	while(j <= right)
	{
		if(j+1 <= right) // 防止数组溢出
		{
			j = nums[j] > nums[j+1] ? j : j+1; // j指向左右孩子中更大的那个			
		}
		if(nums[i] < nums[j]) // 如果父节点比孩子节点小
		{
			swap(nums[i], nums[j]); // 交换两个节点
             // 下一层的调整
			i = j; // 当前要调整的节点改为刚交换的孩子节点
			j = 2*i+1; // 刚交换的孩子节点的左孩子
		}
		else break; // 如果父节点比孩子节点还大，那么就不需要调整了，此时已经为堆
	}
}
```

现在我们可以来看看堆排序怎么操作了：
堆排序是基于堆的特性进行排序的方法，基本思想是：先将待排序序列调整成一个堆（以大根堆为例），然后选出堆顶元素将其移走，然后将剩下的元素再调整成堆，然后再从这个堆选出堆顶元素移走。。。这样最后慢慢地就可以选出最大、次大、次次大直到最后一个元素。

在堆排序中，有三个关键问题需要处理：

1. 如何把待排序序列调整成一个堆？
   - 在堆调整算法中，可以将完全二叉树变成一个堆的前提是根结点的左右孩子都是堆，那么左右孩子要是堆，左孩子的左右孩子也要是堆，右孩子的左右孩子也要是堆。。。最后，当节点的孩子是叶子节点的时候，就只需要节点大于两个孩子就满足堆的要求了。
   - 那么按照这个思路，我们能否从树的底部那些父节点开始做堆调整，然后逐步地向上做堆调整，直到最后对根结点做堆调整呢？事实上是可以的，因为从树的底部开始做堆调整，那么就保证了树的底部父节点都是堆，那么它们的父节点也可以通过堆调整算法来成为堆，最后根结点也可以通过堆调整算法来成为堆。
2. 如何把堆顶元素移走？
   - 堆顶元素是最大值，不妨我们将这个元素放到数组的末尾（它们本来应该在的位置），也就是堆顶元素和最后一个元素交换。第二轮开始之前，因为现在的堆顶元素已经不是最大值了，而堆顶节点的左右孩子还是堆，是满足使用堆调整的，因此我们需要做一次堆调整来重新构建一个堆，然后进行第二轮。
   - 第二轮，我们再次把堆顶元素和倒数第二个元素交换（因为这时的堆顶元素是次大元素），交换后再次做堆调整，已经排序好的就不需要参与堆调整了。
   - 第 i 轮，堆顶元素和 nums.size() - i 个元素交换。 
3. 剩下的元素怎么调整成一个新的堆？
   - 对剩下的元素做堆调整。

整个堆排序过程的动画如下：

<video src="https://vdn6.vzuu.com/SD/3bb38dfe-236a-11eb-8039-a6caf32b14c9.mp4?pkey=AAVzJA_pmqS_-hACrluZIATQsUWLaLNo9scSoxquywCFQtBWwnOJHzMr4_H3zTcOYoCe2GfRvZjbRQhaychwytVs&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1677163917&v=ks6"></video>

堆排序的代码如下：

```c++
void sift(vector<int>& nums, int node, int right)
{
	int i = node;
	int j = 2*i+1;
	while(j <= right)
	{
		if(j+1 <= right)
		{
			j = nums[j] > nums[j+1] ? j : j+1;			
		}
		if(nums[i] < nums[j])
		{
			swap(nums[i], nums[j]);
			i = j;
			j = 2*i+1;
		}
		else break;
	}
}

void heapSort(vector<int>& nums)
{
	for(int i = nums.size()/2 - 1; i>=0; i--) // j = 2 * i + 1，那么i = (j - 1) / 2，求的是从最后一个叶子节点开始往上的每个父节点的位置，直到根结点
	{
		sift(nums, i, nums.size()-1); // 对当前父节点i做堆调整
	}
	for(int i = 0; i<nums.size()-1; i++) // i-1次交换，最后无序区还剩一个元素就不用交换了
	{
		swap(nums[0], nums[nums.size()-1 - i]); // 将堆顶元素交换到后面的有序区
		sift(nums, 0, nums.size()-2 - i); // 对无序区重新构建堆，注意是nums.size() - 2 - i，因为无序区为[0, nums.size()-2-i]
	}
}

```

我们来看看堆排序的稳定性，先说结论，不稳定。
老例子待排序序列{2, 2 *, 1}，天然的大根堆，将堆顶元素2交换到尾部即{1, 2 *, 2}，无序区重新堆调整为{2 *, 1}，将堆顶元素交换到尾部即{1, 2 *}，算法结束，最后得到的序列为{1, 2 *, 2}，使用堆排序后相同元素的相对位置发生了改变，因此堆排序是不稳定的算法。

再来看看堆排序的空间复杂度和时间复杂度。

因为在堆排序中在交换的时候使用了一个暂存单元，因此空间复杂度为O(1)。

在最好、最坏、平均的情况下，推排序的时间复杂度都是O(nlog2n)，因为推排序对排序序列的初始状态并不敏感，相对于快速排序来说，这是推排序最大的优点。
堆排序中初始建堆需要O(nlog2n)时间，第i次取堆顶元素重建堆需要用O(log2i)时间，并且需要取n-1次堆顶元素，因此总的时间复杂度为O(nlog2n)。
