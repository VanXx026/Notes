# 希尔排序

希尔排序也属于插入排序，它是一个改进版的插入排序算法。为什么要改进直接插入排序呢？这是因为直接插入排序有两个特点：

1. 如果待排序序列基本有序，效率很高。
   - 基本有序，说明还差几个元素没排好就有序了。而直接插入排序最优即待排序序列完全有序的时候，时间复杂度是O(n)。
2. 如果待排序序列元素很少的时候，效率很高。
   - 当待排序序列只有两三个元素的时候，确实要比十多个元素快，因为待排元素离他们的正确位置很近，很快就能插入过去。

基于这两个特点，希尔排序是这样优化的：先将整个待排序序列分割成若干个子序列，然后对这若干个子序列（更短）分别使用直接插入排序，等到序列基本有序（更快）的时候，再对整个序列使用一次直接插入排序。

- 怎么分割子序列才能使得序列可以基本有序呢？通过一个变量d。
  d：**一个子序列元素之间的间隔distance**。我们使用d来为整个待排序数组划分子序列。

- 怎么使用d来划分呢？
  假如整个待排序数组的长度为n，令d = n / 2，也就是说一个子序列元素之间的间隔是 n / 2。假如n=10，那么一个子序列就有两个元素，这两个元素之间间隔为5。如：{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} => {1, 6} {2, 7} {3, 8} {4, 9} {5, 10}。我们在这样划分之后，对每一个子序列都做直接插入排序；然后我们再缩小间隔d，令d = d / 2，再对划分的子序列做直接插入排序；重复d缩小的过程直到d=1，子序列元素之间的间隔为1，也就是将整个序列最后做一次直接插入排序。

- 为什么这样划分可以让序列基本有序？
  首先，带间隔的划分，可以让在右边的小值快速地插入到左边，同理也让左边的大值快速地插入到右边。然后我们将间隔缩小，比上一轮更细致地将小值和大值插入到更加合理的位置，因此当d逐渐缩小，序列就逐渐有序，直到d=1执行最后一次直接插入排序。
- <img src="https://pic1.zhimg.com/80/v2-9c0b7cda43bb32c4c206d545a3409c80_720w.webp" alt="img" style="zoom: 67%;" />

希尔排序的动画如下：

![动图](https://pic4.zhimg.com/v2-3762149d65540cf3e61b5dfaace6dc7b_b.webp)

代码的逻辑就蕴含在其中，我们刚刚在上面讲的时候，确实是说“对一个划分的子序列做直接插入排序”对吧，但是你看动画中的黄线，每一轮遍历的时候都没有跳跃。比如我有一个子序列是{1, 6, 11}，动画中并没有按照 1 6 11 的直接插入遍历的方式去做。事实上，使用d划分了子序列后，我们的方式还是从左向右地遍历序列（遍历开始的位置由d的值决定），只不过我们在插入元素比较的时候，挪动元素的时候，是跳跃着访问的，d使得我们能够找到同组子序列中的其他元素。

```c++
void shellSort(vector<int>& nums)
{
	int j = 0;
    // d：一个子序列中各元素的间隔distance
	for(int d = nums.size() / 2; d>=1; d/=2) // 间隔d越来越小，直到d=1 
	{
         // 直接插入排序的逻辑
		for(int i = d; i<nums.size(); i++) // 和直接插入排序类似（排序序列是i=1），因为d之前的元素在各自的子序列中只有它自己，因此默认d之前的元素都在各自子序列的已排序序列中。 
		{
			int temp = nums[i]; // 防止nums[i]被覆盖
			for(j = i - d; j>=0 && nums[j]>temp; j-=d) // 将移动和插入的幅度从1变为d，因为子序列之间间隔为d。j=i-d子序列中已排序序列的右边界元素的位置。j-=d是为了找到下一个已排序序列中的元素。
			{
				nums[j + d] = nums[j]; // 将更大的元素向右移
			}
			nums[j + d] = temp; // 循环结束前nums[j] <= temp，因此插入位置是j + d
		}
	}
}
```

老规矩，在写完代码之后，我们来讨论一下稳定性。

先说结论，希尔排序是一个不稳定的排序算法。
举个例子，{2, 2 *, 1}，假如d=2，那么这个序列有两个子序列{2, 1} {2 *}，对第一个子序列做直接插入排序，得{1, 2}，第二个子序列不需要做排序操作，因此最后的子序列变成了{1, 2 *, 2}，因为两个相同元素在排序后的相对位置发生了改变，因此希尔排序是不稳定的排序算法。

最后，我们再来说说算法的空间复杂度和时间复杂度。

空间复杂度就不必多说了，一眼O(1)，下一个。

时间复杂度就比较的难讨论了，因为本身对d的选择就会影响到整个算法的时间复杂度，如果选择了合适的d的增量序列，那么希尔排序的时间性能可以达到O(n ^ 1.3)。
不管最好还是最坏的情况，如果按照上面代码对d的取值，那么第一层循环一定是做了log2n次。
因为内层循环其实就是直接插入排序的逻辑，因此我们可以将直接插入排序的时间复杂度套进来。那么就有：
最好的情况下，整个序列是正序的，那么内部直接插入排序的时间复杂度为O(n)，所以整个算法的时间复杂度为O(log2n * n) = O(nlogn)。
最坏的情况下，整个序列是逆序的，那么内部直接插入排序的时间复杂度为O(n^2)，所以整个算法的时间复杂度为O(n ^ 2 * log2n) = O(n ^ 2 * logn)。（这里我的方法可能是有错的，因为大部分网上都说是O(n ^2)，那么就以O(n ^ 2)为准）