# 简单选择排序

简单选择排序为什么叫简单选择排序？
首先它简单，是因为这是下意识能想到的，最为直觉的排序算法了。正因如此，它也是最没用的算法。
选择，是指每次排序都从待排序列中**选择一个最小值**来操作，因为有选择的操作，因此叫做选择排序。

那么选择排序大概是怎么样的呢？

> 简单选择排序
>
> 1. 定义一个范围，作为待排序数组的范围，初始时整个数组都是待排序数组。
> 2. 遍历这个待排序数组，找到其中的**最小值**，并与待排序数组的**左边界交换**，交换后，将**左边界右移**。
> 3. 重复第二步直到整个数组排序完成。

最关键的步骤就是找到最小值并做出交换的操作，这是简单选择排序最核心的一步。

如果用动图来表示，整个过程是这样的：

![动图](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

- 蓝色的部分是待排序的部分，黄色的部分是已排序的部分，每一次执行都从待排序部分的左边界开始。
- 红色标识的是当前所找到的最小值
- 绿色标识是正在遍历的位置

以下是代码实现：

```c++
void selectSort(vector<int>& nums) {
    // 待排序部分即[i, nums.size()-1]
	for(int i = 0; i<nums.size()-1; i++) // 细节1：nums.size()-1，因为待排序部分只剩下最后一个元素的时候，就没有必要执行了
	{
		int minIndex = i; // 将最小值下标初始化为待排序部分的左边界i
		for(int j = i+1; j<nums.size(); j++) // 细节2：这个循环是为了找到待排序部分中的最小值位置，因此从i+1开始
		{
			if(nums[minIndex] > nums[j]) 
			{
				minIndex = j;
			}
		}
		if(minIndex != i) // 细节3：优化，如果左边界一开始就是最小值，那么不需要做交换操作
		{
			int temp = nums[minIndex];
			nums[minIndex] = nums[i];
			nums[i] = temp;
		}
	}
}
```

先来说说稳定性问题，先说结论，简单选择排序是不稳定的排序算法。
还是用那个例子，排序之前的序列是{2, 2 *, 1}，使用简单选择排序之后，第一次选择到的最小值是1，就和左边界2做交换，最后的结果就变成了{1, 2 *, 2}，相等的元素相对位置却改变了，因此是不稳定的。

不稳定会带来什么影响呢？打个比方，张三和李四的年纪一样大，可是他们在银行的存款张三比李四多，现在如果选择用简单排序算法对银行用户进行排序，结果排着排着本来张三是在前面的，结果张三跑到后面去了，但是银行的存款张三是要比李四多的，因此这就会导致某些预料不到的错误发生。

接下来根据代码，我们来讨论一下简单选择排序算法的时间复杂度和空间复杂度。

首先时间复杂度按照大O表示法，耗时最多的自然就是两层嵌套循环中的判断操作，时间复杂度即(n-1) + (n-2) + ... + 1。根据数列的累加公式：(首数值 + 尾数值) * (数列个数 / 2)，代入公式中即 ((n-1) + 1) * ((n-1) / 2) = n*(n-1) / 2，严格一点的话还要加上在一层循环中的交换操作，因此记为n-1。
所以最后时间复杂度为O(n * (n-1) / 2 + n - 1) = O(n*n + n) = O(n ^ 2)。

另外，最好的情况当然是输入的是一个顺序且有序的序列，这时简单选择排序依然会做最小值判断，所以时间复杂度还是O(n ^ 2)，最坏的情况是输入的是一个逆序且有序的序列，同样会做最小值判断，因此时间复杂度还是O(n ^ 2)。

空间复杂度，由于算法中除了输入的数组之外没有额外使用另外的数组，并且算法中只使用了若干个变量，并且这些变量并不会随着数据的规模而越用越多，因此简单选择排序算法的空间复杂度为O(1)。



简单选择排序也是可以优化的，比如每次循环在找最小值的时候顺便把最大值也找了，将最小值赋给左边界，将最大值赋给右边界。
