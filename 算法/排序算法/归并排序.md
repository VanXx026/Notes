# 归并排序

归并排序，我觉得它可以叫递归合并排序，因为它的主要思想就是将一个序列先划分开，然后再合并起来变成一个有序序列。
归并排序大部分情况下都是使用二路归并来实现，因为它最简单，而且效率也不错。

## 二路归并排序的递归实现

二路归并排序递归实现的基本思想是：将待排序序列**划分成两个长度相等的子序列**，然后接着再把这两个长度相等的子序列再次划分成它们各自的两个子序列，接着划分，直到最后待排序序列被划分成了n个长度为1的子序列。长度为1的子序列肯定就是有序的了。然后再向上合并，两个长度为1的子序列合并成长度为2的有序序列，两个长度为2的有序序列再合并成长度为4的有序序列，最后将整个序列变成有序序列。
递归树如图所示，其中节点值为子序列的长度。

<img src="C:\Users\Van\AppData\Roaming\Typora\typora-user-images\image-20230223171318398.png" alt="image-20230223171318398" style="zoom: 80%;" />

这个思路有一个关键问题需要解决，我们怎么把两个有序子序列合并成一个有序序列呢？
这其实是一个很简单的数组双指针问题，我们为这两个有序子序列分别提供一个指针p1、p2，然后新开辟一个空间用来装合并之后的有序序列。在遍历的过程中，两个子序列之间的值相比较，值较小的就装入新数组中，然后指针右移，直到两个序列的指针都指向了尾部，序列就合并好了。新序列合并好之后，再将原先两个有序子序列所在的对应位置覆盖，那么就完成了。
代码如下：

```c++
void merge(vector<int>& nums, int left, int right, int right2)
{
	int p1 = left; // 第一个有序子序列的头部
	int p2 = right+1; // 第二个有序子序列的头部
	vector<int> temp(right2 - left + 1, 0); // 临时容器，用于临时存放合并好的序列
	int p = 0; // 临时容器的指针
	while(p1 <= right && p2 <= right2)
	{
		if(nums[p1] < nums[p2])
		{
			temp[p++] = nums[p1++];
		}
		else
		{
			temp[p++] = nums[p2++];
		}
	}
	while(p1 <= right) // 当第二个序列已经结束扫描时，第一个序列还没结束
	{
		temp[p++] = nums[p1++]; // 把第一个序列剩下的元素载入临时容器中
	}
	while(p2 <= right2) // 当第一个序列已经结束扫描时，第二个序列还没有结束
	{
		temp[p++] = nums[p2++]; // 把第二个序列剩下的元素载入临时容器中
	}
	for(int i = 0; i<temp.size(); i++) // 将合并结果传回原容器
	{
		nums[i+left] = temp[i]; // 注意是nums[i+left]，要对应上位置
	}
	vector<int>().swap(temp); // temp.clear()不会清除空间，只会清除数据，而temp与匿名空容器交换，可以达到清除空间的效果 
}
```

解决了合并问题，最后只需要写二路归并算法的递归主逻辑就可以了，代码如下：

```c++
void mergeSort(vector<int>& nums, int left, int right)
{
	if(left >= right) return;
	int mid = (right - left) / 2 + left; // 取中间值，尽量将序列分成两个大小相等的子序列
	mergeSort(nums, left, mid); // 左序列，范围为[left, mid]
	mergeSort(nums, mid+1, right); // 右序列，范围为[mid+1, right]
	merge(nums, left, mid, right); // 将左右序列合并
}
```

使用二路归并排序的递归实现的动画如下：

<img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp" alt="动图" style="zoom:80%;" />



最后，我们来看看二路归并排序的稳定性，先说结论，
还是那个老例子{2, 2 *, 1}，一开始划分成左序列{2, 2 *}，右序列{1}，左序列再次划分并且合并，还是{2, 2 *}，然后将{2, 2 *} {1}进行合并，最终得{1, 2, 2 *}，可以发现，相同元素的相对位置并没有发生改变，因此二路归并排序是稳定的。

然后我们来讨论一下空间复杂度和时间复杂度。

通过观察可以发现，归并排序对待排序序列的状态并不敏感，因此最坏，最好，平均的情况下时间复杂度应该是一样的。
假设二路归并排序对于规模为n的序列需要T(n)，并且合并算法我们可以简单分析成O(n)，那么就有：
T(n) = 2T(n/2) + n = O(nlogn)，和快速排序一样。

二路归并排序在执行的过程中，需要使用与当前传入的序列使用同规模的空间，并且合并完成后释放空间，因此空间复杂度为O(n)。



## 二路归并排序的非递归实现

如果说二路归并排序的递归算法是**自顶向下**的划分与合并，那么二路归并排序的非递归算法就是自底向上的划分与合并了。
二路归并排序的非递归实现的基本思想是：一开始将长度为n的序列看成n个长度为1的有序子序列，然后进行两两合并，得到 n/2 个长度为2（最后一个序列可能长度为1）的有序子序列，然后再次合并，得到 n/4 个长度为4的有序子序列（最后一个序列的长度可能小于4），重复合并，直到最后得到长度为n的有序序列。

<img src="E:\VanSama no note\算法\排序算法\mergeSort.jpg" alt="mergeSort" style="zoom: 25%;" />

这种思路有一个关键问题需要解决：如何实现有序子序列的两两合并并且完成一轮归并？

两两合并很简单，使用我们在递归实现中使用的合并方法就可以了。但是在合并时，因为划分的时候，有可能在末尾的子序列是稍短一些的，那么这时候就有三种情况：假设当前划分的子序列的长度用h来表示（最后一个子序列不一定为h），设 i 指向两个合并序列中第一个序列的首部位置。

1. 如果 i + 2h <= nums.size()，i + 2h 记为下一个合并组合的第一个序列的首部。当前下标i加上两倍子序列长度都没有越界，说明有两个长度为h的子序列，[i, i+h-1] [i+h, i+2h-1]。
2. 如果 i + h < nums.size()，i + h 记为当前合并组合的第二个序列的首部。如果第二个序列的首部没有越界，说明第一个序列的长度为h，第二个序列的长度小于h，即[i, i+h-1] [i+h, nums.size()-1]。
3. 如果 i + h >= nums.size()，i + h 记为当前合并组合的第二个序列的首部。如果第二个序列的首部越界了，说明现在只有一个序列，因此不需要做合并操作。

因此每一轮归并排序应该是这样的，代码如下：

```c++
void mergePass(vector<int>& nums, int h)
{
	int i = 0; // 指向合并序列中第一个序列的首部
	while(i + 2*h <= nums.size()) // 对应第一种情况
	{
		merge(nums, i, i+h-1, i+2*h-1); // 序列的范围都是左闭右闭的
		i += 2*h; // 以2h的步数跳跃以达到下一组合并序列中第一个序列的首部
	}
	if(i + h < nums.size()) // 对应第二种情况，这种情况通常发生在每一轮归并的尾部
	{
		merge(nums, i, i+h-1, nums.size()-1);
	}
    // 因为第三种情况不需要做合并操作，因此不需要写
}
```

那么一轮归并排序的过程我们写好了，我们怎么控制整个归并排序执行呢？用h：当前划分的子序列的长度，一开始我们划分长度为1的子序列，然后划分为长度h=2，然后划分为长度h=4，在逐渐合并后h=n即完成算法。

```c++
void mergeSort2(vector<int>& nums)
{
	int h = 1; // 初始时划分子序列长度为1
	while(h <= nums.size()-1)
	{
		mergePass(nums, h); // 一轮归并排序
		h *= 2; // 归并排序结束后将划分子序列的长度扩大一倍即h=2h
	}
}
```

剩下的稳定性和时间复杂度空间复杂度我们在递归实现中已经讨论过了，因此不再赘述。