# 直接插入排序

直接插入排序是插入排序中最简单的一种，类似于打牌的时候整理手牌的过程。插入排序的基本思想是在待排序序列中选择一个元素，将其插入到排序序列中，直到整个序列排序完成。直接插入排序的核心是**待排序插入排序中**。

直接插入排序的动画如下：

<img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp" alt="动图" style="zoom:80%;" />

- 蓝色部分是待排序序列
- 黄色部分是已排序序列
- 红色标识的是当前的插入元素
- 绿色标识的是插入时所比较的元素

> 直接插入排序
>
> 1. 选择待排序序列中的第一个元素作为插入元素，在排序序列中从右往左依次比较，如果该元素更小，则与之交换位置，直到该元素不需要交换为止（即插入到了合适的位置）
> 2. 重复步骤1直到序列有序。

这是这种做法的代码实现：

```c++
// 这种做法是插入元素往前移
void insertSort(vector<int>& nums)
{
	for(int i = 1; i<nums.size(); i++) // 当i=0时，即待插入元素是nums[0]，其实根本就没有插入的环节，因此直接优化为i=1
	{
		int j = i; // 记录当前的插入元素位置
		while(nums[j] < nums[j-1] && j>1) // 如果插入元素更小
		{
             // 交换
			int temp = nums[j];
			nums[j] = nums[j-1];
			nums[j-1] = temp;
			j--; // 插入元素位置变化
		}
	}
}
```

虽然大体上的实现是没有问题的，确实是直接插入算法，也比较直观。但是这种做法很容易和冒泡排序混淆，而且每次循环都要做很多次交换的操作，因此效率上也比较低。为什么我们要一直交换到合适位置而不是先找到合适位置再将元素交换（插入）呢？

> 直接插入排序
>
> 1. 选择待排序序列中的第一个元素作为插入元素，在已排序序列中从右往左与插入元素比较，如果插入元素更大，那么就把当前比较的已排序序列中的元素向右移，直到该元素比插入元素小，即找到了插入元素的插入位置。
> 2. 重复步骤1直到序列有序。

就像这样，我们之后都以这种做法为主：

```c++
// 这种做法是已排序序列往后挪
void insertSort(vector<int>& nums)
{
	int j = 0; // 提前初始化
	for(int i = 1; i<nums.size(); i++) // 优化思路同上
	{
		int temp = nums[i]; // 记录插入元素的值
		for(j = i-1; j>=0 && nums[j]>temp; j--) // 这个循环用于找到插入的位置
		{
			nums[j+1] = nums[j]; // 将已排序序列中比待插入元素大的值向后移
		}
		nums[j+1] = temp; // 将插入元素插入到合适位置，为什么是j+1而不是j呢？因为循环退出的条件是nums[j]>temp，循环退出说明nums[j]的值比插入元素小，因此插入元素的位置应该在j+1。
	}
}
```

按照惯例，我们来看看直接插入排序算法的稳定性。
还是那个例子{2, 2 *, 1}，使用直接插入排序，前两轮因为元素相等，因此不会进入内部循环，因此还是{2, 2 *, 1}；
第三轮插入元素为1，此时已排序序列为{2, 2 *}，在循环内，由于已排序序列中两个元素都比1大，因此这两个元素都从右到左往后挪，最后得{1, 2, 2 *}。算法结束，相同的元素位置并没有发生改变，因此我们可以说**简单插入排序算法是稳定的**。

再来讨论直接插入排序算法的时间复杂度和空间复杂度。

空间复杂度就很简单了，只是用了若干个变量来保存临时数据，并不会随着输入序列规模的增大而变多，因此直接插入排序算法的空间复杂度为O(1)。

我们以第二种做法来计算空间复杂度。
最好的情况下，输入序列为正序，内层循环中的终止条件每次只判断一次，因为nums[j]总是小于temp，因此无法进入循环。所以每次内层循环都只执行一次判断，外层循环执行n-1次，因此最好情况下的时间复杂度为O((n-1) * 1) = O(n)。
最坏的情况下，输入序列为逆序，内层循环中插入元素 i 必须同前面的 i - 1 个元素都做比较，因为i的取值从2到n（下标从1开始），所以有 1 + 2 + 3 + ... + (n - 1) = (1 + (n-1)) * (n-1) / 2 = n * (n-1) / 2，因此最坏的情况下时间复杂度为O(n ^ 2)。
平均情况下，可以视为插入元素 i 可能要与前面的 (i-1) / 2 个元素做比较，因为i的取值从2到n，所以有 1 / 2 + 1 + ... + (n-1) / 2 = n * (n-1) / 4。那么最终平均情况下的时间复杂度还是O(n ^ 2)。
