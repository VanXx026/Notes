# 134. 加油站

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/)



这题，还能这样贪心啊，我崩溃了，排除法贪心我是没想到的。要不是看题解，这题我这辈子做不出来了。

## 1. 贪心

首先这题从整体来看，起码可以得到的信息是，如果你的总油量，甚至比路程还少，那么你不管从哪里开始，都是没用的，最后都绕不了一圈这么长。

所以我们判断是否能绕一圈回到起点，就是通过总油量与总路程的比较（在实现中，我们用差值是否小于0）来判断。

然后我再来说说这个排除法贪心是什么意思。

首先，我们维护一个从[start, i]的差值和curSum，用于记录如果从start开始到遍历下标为i的差值之和，差值即rest[i] = gas[i] - cost[i]，start初始为0，即默认从下标0开始。

从下标i开始，curSum记录[start, i]的差值和，如果当前下标i的差值和curSum < 0，那么说明从start开始到i已经没办法再跑下去了，到达不了下一个加油站，所以[start, i]这个范围内都没有办法作为起点，这时start = i + 1，curSum重置为0。

比如差值[-1 2] => 下标为0时curSum = -1，直接就不满足了，所以start = 0 + 1 = 1，curSum重置，最后答案为start = 1；
比如差值[2 -3 4] => 下标为0时curSum = 2，满足，继续遍遍历；下标为1时curSum = 2 - 3 = -1，不满足，所以start = 1 + 1 = 2，curSum重置；下标为2时curSum = 4，满足，遍历到尾部，所以最后答案为2；

可以发现，我们是逐步把前面的位置都排除了，才选到后面的元素，就好像是排除法一样。

你可能会疑惑，排除的范围之后如果还有很多元素呢？为什么只选择范围后的第一个位置？

当然不是这个意思，选择的位置一定是越前越好，因为如果后面的元素差值都是正数，那么位置在前面，就可以累计到更多的油；如果后面有一个位置让curSum<0了，也会立刻抛弃这个start，而选择一个新的start。

所以这道题贪心就贪心在：当前起点向后累加curSum值，如果满足curSum>=0那么就一直累加到遍历结束，只要curSum不会小于0，那么就说明这就是解；如果curSum<0，立即抛弃当前起点，在令curSum<0的位置的下一个位置建立新的起点。

这题非常符合贪心的思路，因为它是目光短浅的，没有直接分析整体上两个数组的特点，没有尝试去直接拿到最优点，而且消极地从最初的位置慢慢排除。

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int totalSum = 0; // 总差值，用来判断最终能不能绕一圈
        int curSum = 0; // 每次start的差值和
        int start = 0; // 起点位置
        for(int i = 0 ; i<gas.size(); i++)
        {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i]; // 通过遍历记录总体差值和
            if(curSum < 0) // 如果当前差值和小于0，说明当前位置i令之前的积累全部达咩，所以start要重新选了
            {
                start = i + 1; // 选择i+1的位置
                curSum = 0; // 重置curSum
            }
        }
        if(totalSum < 0) // 如果totalSum < 0，说明油量比路程量小，怎么也不可能绕一圈
        {
            return -1;
        }
        return start;
    }
};
```





