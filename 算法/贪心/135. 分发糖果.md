# 135. 分发糖果

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/)



## 1. 贪心

这题首先是要理解题意，题目在分发糖果的时候有两个规则：

1. 至少都能分到一个糖果
2. 相邻评分更高的能得到更多的糖果（同评分也不能得到更多的糖果）

题目要求分的糖果尽可能的少，那么就意味着更多的糖果就是在相邻小朋友的基础上多分一颗（真小气）

而且这个分糖果的过程是局部的，而不是全局来看的：比如[1 2 8 3 8]，最后分得糖果的情况是：[1 2 3 1 2]
这意味着当前小朋友分到糖果只和周围的小朋友评分和分到的糖果的情况有关，不管其他小朋友的事。那么这样分糖果就要考虑到左右小朋友的情况，必须得让左右小朋友先分完，当前小朋友才能够做出判断，麻烦就麻烦在这里，我们怎么做才能够在分糖果的时候考虑到两边小朋友的情况？

一开始我的思路是这样的：找到评分最低的小朋友，从这个小朋友开始向左向右的分糖果，向左遍历，当前小朋友参考右边小朋友的情况；向右遍历，当前小朋友参考左边小朋友的情况。因为没有分到过糖果的小朋友是不能作为参考的，因为这些小朋友能拿到的糖果数不确定。但是这个思路犯了个很关键的错误：向左遍历的时候当前小朋友没有参考左边小朋友的情况，同理向右遍历的小朋友没有参考右边小朋友的情况。这就造成了顾此失彼的情况。

这时候我就有点茫然了，思路是有了，但是实现上总是有纰漏。稍微去卡尔那扫了一眼，这句话立马就点醒了我：要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，**如果两边一起考虑一定会顾此失彼**。

是啊，既然两边一起比较非常困难，那我们先比较左边的小朋友，再比较右边的小朋友，综合起来当前小朋友的情况不就可以得知了吗？

所以贪心如下：
参考左边小朋友（向右遍历）：
局部最优：如果当前小朋友评分比左边的小朋友高，那么就在左边小朋友分到的糖果数下多得到一颗糖果，否则就只能得到一颗糖果；全局最优：参考左边小朋友得到的最小分糖果数。
参考右边小朋友（向左遍历）：
局部最优：如果当前小朋友评分比右边的小朋友高，那么就在右边小朋友分到的糖果数下多得到一颗糖果，否则就只能得到一颗糖果；全局最优：参考右边小朋友得到的最小分糖果数。
两个全局最优得到最终的全局最优：参考相邻小朋友得到的最小分糖果数。

当然，还有一个细节，因为最终我们是判断两边的小朋友来得到糖果数，那么参考左边小朋友得到的糖果数情况需要和参考右边小朋友得到的糖果数情况做比较。比如当前小朋友比两边的小朋友评分都高，左边小朋友分到了3颗，右边小朋友分到了5颗，那么显然中间的小朋友应该分到6颗才对。所以我们在向右遍历的时候，如果当前小朋友的评分比右边小朋友高，我们还需要让当前小朋友在和左边小朋友比较过后得到的糖果数和这次与右边小朋友比较得到的糖果数相比较，取最大的。

最后的实现如下：

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int ans = 0;
        vector<int> candys(ratings.size(), 1); // 初始化全ra1，因为小朋友至少都能拿一颗糖果
        // 向右遍历，先参考左边小朋友
        for(int i = 1; i<ratings.size(); i++) // 注意开始下标为1，因为位置0的小朋友没有左边小朋友作为参考
        {
            if(ratings[i] > ratings[i-1]) // 比左边小朋友评分高
            {
                candys[i] = candys[i-1] + 1; // 比左边小朋友多拿一颗糖果
            }
        }
        // 向左遍历，再参考右边小朋友
        for(int i = ratings.size() - 2; i>=0; i--) // 同样需要注意下标
        {
            if(ratings[i] > ratings[i+1])
            {
                // 比较参考左右小朋友而得到糖果的情况，取最大
                candys[i] = candys[i] > candys[i+1] + 1 ? candys[i] : candys[i+1]+1;
            }
        }
        // 统计糖果数
        for(int i = 0; i<candys.size(); i++)
        {
            ans += candys[i];
        }
        return ans;
    }
};
```

