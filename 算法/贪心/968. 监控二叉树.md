# 968. 监控二叉树

#### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)



## 1. 贪心

这题肯定是需要通过几个状态值来标记节点状态的，没有状态值标记的话，完全做不了，但是这个节点的状态怎么实现是一个问题，我就是卡在这了，然后就想不下去了，我想到的方法有给节点编号，另外起一个容器来标记：这个方法层序方便，但是如果使用其他遍历方法，节点编号非常难确定，所以否决了；还有就是改变节点的结构，这个在力扣做不到，节点的结构已经给定了。

实在是很久没做二叉树的题，都踏马不会做了，卡尔的方法是**将递归的返回值作为状态值，那么当前节点就可以根据其他节点返回的状态值来决定。**而且因为只需要遍历一次，只需要在遍历到的时候得知到其他节点是什么状态就可以了，没有必要一直保存这个状态值。

状态值可以这样设定：
0 —— 当前节点没有被覆盖
1 —— 当前节点装了摄像头
2 —— 当前节点被覆盖了

对于这题来说，前中后序遍历里面绝对是选择后序遍历，因为后序遍历可以根据左右节点的情况来判断中间节点属于什么状态，并且稍微分析就可以知道，这题的贪心，相邻层之间一般是不会有摄像头的（除非根结点没有覆盖到，需要多加一个摄像头），而且叶子结点绝对不会放摄像头，太亏了。

确定大体方案之后，我们还需要考虑一些问题：

- 空指针是什么状态？
  假设空指针我们设定成0，没有被覆盖，那么叶子结点按道理来说就必须要放摄像头了，这种情况会和单孩子结点混淆，所以不能选0状态。
  当然1状态就更不可能了，只能选择2状态。

- 三种状态如何使用？
  根据这三种状态，有四种情况：
  1. 左右结点都有覆盖（左右结点是空节点也算这种情况内）：中间节点算为0状态。
     <img src="https://img-blog.csdnimg.cn/20201229203710729.png" alt="968.监控二叉树2" style="zoom:50%;" />
  2. 左右节点其中一个没有被覆盖：中间节点算为1状态
     
  3. 左右结点中其中一个装了摄像头：中间节点算为2状态
     <img src="https://img-blog.csdnimg.cn/2020122920362355.png" alt="968.监控二叉树1" style="zoom:50%;" />
  4. 根结点没有被覆盖到：根结点需要额外算为1状态，即多装一个摄像头
     <img src="https://img-blog.csdnimg.cn/20201229203742446.png" alt="968.监控二叉树3" style="zoom:50%;" />

```c++
class Solution {
private:
    int result;
    int traversal(TreeNode* cur) {

        // 空节点，该节点有覆盖
        if (cur == NULL) return 2;

        int left = traversal(cur->left);    // 左
        int right = traversal(cur->right);  // 右

        // 情况1
        // 左右节点都有覆盖
        if (left == 2 && right == 2) return 0;

        // 注意：情况2和情况3不能换位置，因为装摄像头优先于被覆盖，比如 left = 0 right =1 如果让情况3先，当前节点就会先置为状态2了
        
        // 情况2
        // left == 0 && right == 0 左右节点无覆盖
        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        // left == 0 && right == 2 左节点无覆盖，右节点覆盖
        // left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if (left == 0 || right == 0) {
            result++;
            return 1;
        }

        // 情况3
        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        // left == 1 && right == 1 左右节点都有摄像头
        // 其他情况前段代码均已覆盖
        if (left == 1 || right == 1) return 2;

        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        // 这个 return -1 逻辑不会走到这里。
        return -1;
    }

public:
    int minCameraCover(TreeNode* root) {
        result = 0;
        // 情况4
        if (traversal(root) == 0) { // root 无覆盖
            result++;
        }
        return result;
    }
};
```

