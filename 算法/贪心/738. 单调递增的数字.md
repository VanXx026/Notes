# 738. 单调递增的数字

[738. 单调递增的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/monotone-increasing-digits/)



## 1. 贪心

这题我的思路只能对80%个题例，我并没有理解到题目的本质，或者说我的贪心被推翻了，又或者说有点太贪心了，想一次性做完，实际上还是要遍历完才能知道在哪里开始处理。

以98为例，可以很快地知道，它的最大满足数字为89；有时候简单的例子反而能把问题想的跟清楚。。。
这个例子可以告诉我们，**如果相邻两位数，不是递增的，那么可以尝试让前一位-1，后一位变成9**，这样就满足条件了。
988也是一样的，最大递增数字为899。

所以这个时候可以试想一下，是不是所有的数字只要像这样相邻操作，最终就可以得到结果了呢？

但是，还需要考虑一种情况，以332为例：
前两位是没有问题的，而后两位32可以变成29，结果为329，而这时不符合条件的，因为前两位因为后两位改变而发生了变化，此时前两位为32，然后可以变成29，所以最终的结果应该是299。

因为相邻操作会改变这两位数字，所以怎么遍历又成了一个问题，我们应该让后面的数字先做判断，然后再判断前面的数字，这样就不会造成问题了。所以我们应该从后往前遍历。

我们遍历最终的目的是为了找到最后一次两位数不递增的位置，找到这个位置我们对前一个数-1，让后一个数以及往后的所有数都取9，这样才是最大递增数字。

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string numStr = to_string(n); // 让int型转为string，就不用自己去拆分了
        int flag = numStr.size(); // 最后一次不满足两位数递增的位置，也就是开始取9的位置
        for(int i = numStr.size()-1; i>0; i--)
        {
            // 如果相邻两位数不递增
            if(numStr[i-1] > numStr[i])
            {
                numStr[i-1]--; // 前一位数-1，
                flag = i; // 更新当前取9处理的开始位置
            }
        }
        // 从flag位置开始，向后所有数取9
        for(int i = flag; i<numStr.size(); i++)
        {
            numStr[i] = '9';
        }
        return stoi(numStr); // string转回int型
    }
};
```

