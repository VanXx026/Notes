# 53. 最大子数组和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)



这题用暴力ac不了，暴力可以优化到O(n^2)，这题的题例给的数据很大，比较难过。

## 1. 贪心

终于有一题的贪心我是能想到的了，吐了，贪心的思路真的很难想，有时候你甚至都不知道哪里是局部最优，自然无从下手，挺麻烦的。

这题是要求最大的连续子序列和，总体最优当然就是找到一个总和最大的子区间了，那么什么是局部，又怎么最优呢？

如果我们保证每次累加的值sum是大于0的，那么这样累加下去，sum值一定会慢慢增大；如果累加到sum小于或者等于0，那么就意味着接着往下加值还是会小，那么就放弃这个sum值，重置并且从当前累加位置的下一个位置开始再累加。这样做能够保证累加和一定能慢慢增大，**所以我们的局部最优就是：累加值sum都要大于0**。

**这个思路是比较难想的，虽然代码写起来很简单。**

以[-2,1,-3,4,-1,2,1,-5,4]为例：（注意：每一次累加不管重置sum与否，都需要和记录值比较，记录最大的sum值）
-2，sum = -2，直接就不满足局部最优了，重置sum；
1，sum = 1，满足sum > 0，继续；
-3，sum = 1 + (-3) = -2，不满足，重置sum；
4，sum = 4，满足，继续；
-1，sum = 4 + (-1) = 3，满足，继续；
2，sum = 3 + 2 = 5，满足，继续；
1，sum = 5 + 1 = 6，满足，继续；
-5，sum = 6 + (-5) = 1，满足，继续；
4，sum = 1 + 4 = 5，满足，结束；
最终答案为6。

能够想到怎么做局部最优之后，实现还是比较简单的，但是想不到就很折磨，贪心就是这么一个玩意。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int max = INT32_MIN; // int型最小值
        for(int left=0; left<nums.size(); left++)
        {
            sum += nums[left]; // sum累加
            // 比较max记录值
            if(sum > max)
            {
                max = sum;
            }
            // 检查是否局部最优：sum > 0
            if(sum <= 0)
            {
                sum = 0; // 如果不是最优，重置sum值，从下一个下标开始重新记录sum
            }
        }
        return max;
    }
};
```



## 2. 动态规划









