# 452. 用最少数量的箭引爆气球

[452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)



这种题目已经是贪心里面非常困难的了，不仅不会贪，会贪然后不会写。

## 1. 排序 + 贪心

直觉上，用最少数量的箭引爆气球，那么就意味着每次射箭要社保的气球够多，也就是说，要挑重叠气球多的位置来射箭。

那么哪些重叠气球最多呢？这就是难点所在了。

为了方便讨论区间，一般来说都会进行排序，因为气球重叠的位置肯定都是比较接近的，所以排序之后做起来自然是更加方便的。
排序的另外一个好处就是，射箭之后，气球引爆了，也不需要删除元素，直接跳过就可以了，只需要记录箭的数量。

因为排序的目的是让相近的气球集中在一块方便处理，所以按左边界排序还是右边界都没问题。

现在的问题就是如何找到这个射箭的位置了。

稍微分析一下题目，就可以知道，射箭的位置选择气球的右边界就可以了。因为如果两个气球一个右边界大于另一个气球的左边界，那么这两个气球就重合了，虽然重合是重合了，但是会有两种重合的情况：

1. 比如[1 6] [2 5]：这种情况下6 > 2，但是第二个气球的右边界要比第一个气球的右边界要小，所以具体情况就是大气球包着一个小气球，这样的话我们的箭只能选择5这个位置射才能把两个气球都社保，选择位置6就只能社保一个气球。
2. 比如[1 6] [2 7]：这种情况下6 > 2，第二个气球右边界要比第一个气球的右边界大，所以具体情况是两个气球有交集，这样的话我们选择位置6就可以把两个气球都社保，选择位置7就只能社保第二个气球。

**所以可以看出，如果气球有重合，也不是说随便选择射箭的位置就能把重合的气球都社保，而是选择重合气球中右边界最小的位置来射箭，这样就能保证全部气球都能社保了。**所以我们在遍历的时候，还必须更新当前重合气球集合的最小右边界。

<img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球" style="zoom: 80%;" />

代码如下：

```c++
class Solution {
public:
    // 按左边界从小到大排序
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int arrowNum = 1; // 如果存在气球，至少都需要射一支箭
        for(int i = 0; i<points.size()-1; i++)
        {
            if(points[i][1] < points[i+1][0]) // 相邻两个气球没有交集
            {
                arrowNum++; // 需要额外多一支箭来射一个单独的气球
            }
            else // 相邻气球存在交集
            {
                points[i+1][1] = min(points[i][1], points[i+1][1]); // 更新存在交集的气球中的最小右边界，并赋给i+1的右边界，用于后续的相邻比较
            }
        }
        return arrowNum;
    }
};
```

这题的思路实际上真的很难想，在分析的时候真的不一定能想到最小右边界的，这就是贪心的恐怖之处，没有任何套路，只能通过做题积累经验以及临场分析来ac题目。