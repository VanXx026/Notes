# 算法复杂度分析

> 在讨论递归的算法复杂度时，最好将递归抽象为树结构，再根据公式来得到时间复杂度和空间复杂度。
> 递归算法的时间复杂度 = **树节点个数 * 每次递归的时间复杂度**，有时候每次递归的空间复杂度都不相同，比如快排。
> 还有另一种公式法：
>
> - ​                        c                    n = 1
> - T(n) = {
> - ​              aT(n/b) + cn^k         n > 1
>
> 这个递推式描述了大小为n的原问题被分成若干个大小为n/b的子问题，其中a个子问题需要求解，而cn^k是合并各个子问题的解需要的工作量。
>
> 递归算法的空间复杂度 = **树的深度 * 每次递归的空间复杂度**



## 1. 大O表示

在算法导论中，大O是用来表示算法复杂度的上界的，也就是最坏情况。

但是平时在讨论复杂度的时候，**我们默认使用大O都是指一般情况**，当然有时候也会讨论最好的情况以及最坏的情况，因为数据用例的不同，实际上有些算法的事件复杂度有时候不是一样的：

<img src="https://img-blog.csdnimg.cn/20200728185745611.png" alt="时间复杂度4，一般情况下的时间复杂度" style="zoom:67%;" />

一般情况下，大O表示的时间复杂度有如下不等式：

**O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶**



## 2. O(logn)中的log是以什么为底？

其实什么为底都可以，我们省略了这个底。因为大O表示法的特点，因此不同底之间的大O表示可以通过换底公式再省略常数以等价。

<img src="https://img-blog.csdnimg.cn/20200728191447349.png" alt="时间复杂度1.png" style="zoom:67%;" />



## 3. 非递归时间复杂度分析

非递归情况下的时间复杂度大部分情况下是比较简单的，非递归总会有一个解题步骤，将每一个步骤的关键操作分析好最后再拼接就可以了。

比如这里有一道题，题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串），假设字符串的长度是m。

如果使用暴力枚举的方法，实际上有两个步骤：

1. 找到两个字符串做比较
   - 因为有n个字符串，因此找到两个字符串用于比对的组合有 n * n 种
2. 两个字符串进行比对
   - 因为字符串的长度为m，因此逐字符比对最多需要 m 次操作

最后，因为两个步骤是嵌套关系，因此乘算，最后得时间复杂度为 n * n * m，即O(n * n * m)。

我们再换个思路，如果先按字典顺序排序，排序后的字符串集合中，相同的字符串应该相邻，因此在排序之后，我们只需要找到相邻的相等字符串即可。步骤如下：

1. 排序操作
   - 如果对字符串集合使用快速排序的话，因为每个字符串的字符都要遍历一次，因此为 m * n * logn
2. 遍历字符串集合，相邻地找字符串比对组合，并逐一比对字符
   - 相邻的找字符串比对组合，可以找 n-1 种，省略常数，即n种
   - 逐一比对字符，即m次操作
   - 因此该步骤的复杂度为 n * m

因为两个步骤是顺序关系，因此加算，得 m * n * logn + n * m = (m * n)(logn + 1)，省略常数，最后得O(m * n * logn)

最后，根据时间复杂度比较，第二种做法时间效率上要优于第一种做法。



## 4. 递归时间复杂度分析

通过一道题目，我们把递归的时间复杂度讲清楚：求x的n次方（不考虑n为负数）：[50. Pow(x, n)（考虑负数）](https://leetcode.cn/problems/powx-n/)

当然，一看到这样的题，最直接的做法肯定就是直接连乘x了：

```c++
class Solution {
public:
    // 考虑负数，但是是不是负数就讲清楚递归的时间复杂度来说不是重点。
    double myPow(double x, int n) {
        double ans = 1;
        for(int i = 0; i<=abs(n)-1; i++)
        {
            ans = ans * x;
        }
        return n > 0 ? ans : 1/ans;
    }
};
```

这种方法，主要操作在于循环内的连乘，循环内一共执行了 (n - 1) - 0 + 1 即 n 次，所以时间复杂度为O(n)。

这题还有递归的做法，而且递归中还有不同的写法，有的写法和第一种一样都是O(n)，有的写法可以达到O(logn)。

第一种递归的思路是这样的：要想知道x ^ n，就必须先知道x ^ (n -1)，然后就要知道 x ^ (n -2)...直到 n = 0 即 x ^ 0 = 1。

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if(n == 0) // 递归终止条件
        {
            return 1;
        }
        return n > 0 ? myPow(x, abs(n)-1) * x : 1 / (myPow(x, abs(n)-1) * x);
    }
};
```

那么递归的时间复杂度是怎么算的呢？递归算法的时间复杂度本质上是要看: **递归的次数 * 每次递归中的操作次数**。

那么我们来看看这题中递归做了多少次以及每次递归的操作次数。

首先递归的终止条件是 n = 0，而每次递归传参 n 都减1，因此递归的次数是 n 。

其次，每次递归中都做了一次乘法运算，因此记为一次操作。

最后，这种做法的时间复杂度即O(n * 1) = O(n)。

呃呃，因为使用递归还需要额外的栈空间，属于是优化了个寂寞，因此这种做法是不可取的。

还有一种递归做法，这种做法叫快速幂算法，这种算法的本质是分治。

举个例子，如果我们要计算x ^ 64，可以这样来算：x => x ^ 2 => x ^ 4 => x ^ 8 => x ^ 16 => x ^ 32 => x ^ 64，即如果要得到 x ^ 64 = x ^ 32 * x ^ 32，得到 x ^ 32 就要 x ^ 16 * x ^ 16...这样就有了递归的基础。而且这种递归，计算 x ^ 64 只需要 6 步，而上一种递归做法却要64步，因此可以说这种算法是对数阶的，O(logn)。

当然，并不是所有的 n 都是2的次幂的形式。如果要计算x ^ 10，就没有这么简单了。
x => x ^ 2 => x ^ 5 => x ^ 10，这个 x ^ 5 是怎么跑出来的？如果从左往右的话，确实很抽象。但是从右往左看，就清楚一些了：如果要得到x ^ 10，按照分治的思想，模仿上面的做法，x ^ 10 = x ^ 5 * x ^ 5，得到 x ^ 5 的话，就只能是 x ^ 5 = x ^ 2 * x ^ 3 = x ^ 2 * x ^ 2 * x 了，现在有个问题就是，n / 2（10 / 2 = 5，5 / 2 = 2）的时候，有时需要额外乘x，有时又不需要乘x，原因在于 n 能不能被2整除。

如果 n % 2 == 1，即 n 不能被2整除，那么 x ^ n = x ^ (n/2) * x ^ (n/2) * n
如果 n % 2 == 0，即 n 可以被2整除，那么 x ^ n = x ^ (n/2) * x ^ (n/2)

因此我们可以写出这样的代码：

```c++
class Solution {
public:
    double quickMul(double x, long long n) {
        if(n == 0)
        {
            return 1;
        }
        if(n % 2 == 1) return quickMul(x , n / 2) * quickMul(x , n / 2) * x; // n不能被2整除
        else return quickMul(x , n / 2) * quickMul(x , n / 2); // n可以被2整除
    }

    double myPow(double x, int n)
    {
        long long N = n;
        return n > 0 ? quickMul(x, N) : 1 / quickMul(x, -N);
    }
};
```

我们来试着分析一下这种做法的时间复杂度，同样是 递归的次数 * 每次递归的操作次数。

以 n = 16 为例，我们可以将递归抽象成树结构，这和我们把回溯抽象成树结构其实是一样的。因为我们每一次递归都会调用两次自身，因此树的结构就是满二叉树：

<img src="https://img-blog.csdnimg.cn/20201209193909426.png" alt="递归算法的时间复杂度" style="zoom:67%;" />

图中的节点值可以看成是每次递归的 n 值，当 n = 2 时，往下递归就 n / 2 = 1 到达终止条件了，因此不再有节点。

因为一个节点表示一个递归调用，因此我们可以知道递归的次数就是节点个数，满二叉树的节点算法很简单了：2 ^ 0 + 2 ^ 1 + 2 ^ 2 + 2 ^ 3 = 15。再抽象回树的深度m（从0开始算），递归的次数就是 2 ^ m + 2 ^ (m-1) + 2 ^ (m-2) + ... + 2 ^ 0 = 2 ^ (m + 1) - 1，树的深度 m = log2 n - 1，带入 2 ^ (m + 1) - 1 = 2 ^ (log2 n - 1 + 1) - 1 = 2 ^ log2 n - 1，这就是这个做法的递归次数。

再来看每次递归的操作次数，这个做法的主要操作就是一行乘法，因此每次递归的操作次数就是1。

所以，这种做法的时间复杂度为O(2 ^ log2 n - 1) = O(n - 1) = O(n)。

呃呃，怎么回事呢？我们在分析的时候，明明时间复杂度应该是对数阶的，为什么到最后一顿分析又变成了O(n)呢？

这是因为我们在递归中重复计算了 x ^ (n/2)， 导致在每次递归中都有两次递归调用，慢慢的分枝，递归的次数就越来越多了。

因此我们需要将重复计算的问题解决，就像这样：

```c++
class Solution {
public:
    double quickMul(double x, long long n) {
        if(n == 0)
        {
            return 1;
        }
        double temp = quickMul(x , n / 2); // 先记录递归调用的值
        return n % 2 == 1 ? temp * temp * x : temp * temp; // 递归返回之后再使用这个值
    }

    double myPow(double x, int n)
    {
        long long N = n;
        return n > 0 ? quickMul(x, N) : 1 / quickMul(x, -N);
    }
};
```

这样一来，一次递归就只有一次调用了，这时的递归就可以抽象成一颗单叉树。如果 n = 16，16 => 8 => 4 => 2，有4个节点，树的深度是4，再抽象到n，每次调用都是 n / 2，因此递归次数为 log2n。

因为每次递归都做了一次乘法操作，因此可以视为1次操作。

因此这种做法的递归的时间复杂度为O(log2n * 1) = O(logn)。



## 5. 非递归空间复杂度分析

空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。但由于很多因素会影响程序真正的内存使用大小，比如内存对齐，容器的底层实现等都会影响到程序内存的开销，因此空间复杂度是程序员预先大概估计程序内存使用大小的手段。

空间复杂度为O(1)即常数级：通常在函数中只使用了若干个变量来存储数据，并不随着数据集增大而线性增大。

空间复杂度为O(n)即线性级：通常使用某些容器来存储数据，并且消耗的空间和数据集保持线性的增长。比如存储一些长度不等的数组。

空间复杂度为O(n ^ 2)使用的就是矩阵级别的空间了。

空间复杂度为O(n ^ 3)比较少见，但还是存在的。



## 6. 递归空间复杂度分析

我们以两个例子来看看递归中空间复杂度怎么分析：

首先以斐波那契数列为例，代码如下：

```c++
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i-1) + fibonacci(i-2);
}
```

我们先来看看这种做法的时间复杂度如何，先把递归抽象为树结构：

<img src="https://img-blog.csdnimg.cn/20210305093200104.png" alt="递归空间复杂度分析" style="zoom: 50%;" />

可以看到，要想得到f(5)，最后必须要得到f(0)和f(1)，因此树的深度（从1开始算）为5，因此要想得到f(i)，那么最后树的深度就是 i ，又因为深度为k（从1开始）的二叉树节点数最多为 2 ^ k - 1个，因此这种做法的递归次数最多为 2 ^ k - 1次。然后每一次递归调用都有一次加法操作，因此每次递归的操作数为1。所以这种做法的时间复杂度为O(2 ^ k - 1) = O(2 ^ k) = O(2 ^ n)。

我们再来看看空间复杂度，**递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度**。

这里有一个疑问，为什么是递归深度而不是节点个数呢？

因为每次递归所需的空间都被压到调用栈中，每次递归结束，这个栈就会把本次递归的数据弹出去，所以在递归的时候，内存消耗不是一直增大的，而是随着压入而使用内存，随着弹出而释放内存，因此当递归调用的深度最大的时候，所使用的栈空间就最多，因此我们需要的是递归深度而不是节点个数。

每次递归，我们都只需要存储一个返回值，因此每次递归的使用的空间是常数级的，即O(1)。

刚刚我们也说了，这种做法的递归深度是 i，即f(i)的i。

因此最后空间复杂度为O(1 * i) = O(i) = O(n)。

然后我们再来看看二分查找的递归实现，并分析一下空间复杂度：

```c++
int binary_search( int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binary_search(arr, l, mid - 1, x);
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```

讨论空间复杂度，我们还是看每次递归的空间复杂度和递归深度。

先来看看每次递归的空间复杂度，每次递归中除了使用若干个变量之外，还用了一个数组作为参数，但需要注意的是C++中函数传递数组参数并不整个数组拷贝一份传入函数中，而是拷贝了一份数组的首地址传入函数中，需要的时候再根据这个拷贝的地址值找到数组的首部使用。因此在这里，每一次递归使用的空间都是常数级的。即O(1)。

再来看看递归的深度，根据二分查找的特点，很容易就可以知道二分查找的递归深度是log2n，递归深度自然就是调用栈的长度，因此O(log2n) = O(logn)。

最后，可以得知整个算法的空间复杂度就是O(1 * logn) = O(logn)。

