# 142.环形链表Ⅱ

 [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)



首先这题有两种做法，哈希表是比较简单的做法，快慢双指针比较难，但是很精髓。

## 1. 哈希表





## 2. 快慢双指针

快慢双指针，老实说我很快就想到了，但是我想了一会就开始疑惑：

快慢指针相遇的地方，一定是入环的位置吗？

我测试了一会后发现不是：因为入环前还有一段距离，而这段距离决定了快指针不可避免地先比慢指针先入环，这样就不一定在入环点相遇了（在入环点相遇的条件是：两个指针同时入环，因为快指针的路程一定是慢指针的两倍）。

然后我就想办法推导入环前的距离和环内相遇点的关系，然后没想出来。。。

老实说这个数学推导过程我没有自信能比卡尔讲得好：https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E8%A1%A5%E5%85%85

我疑惑的点主要有两个：

1. 为什么慢指针在第一圈就会被追上？
2. 为什么快指针不会跳过慢指针？

第一个问题：卡尔的图已经说的很明白了。首先，快指针和慢指针最终在环内相遇时，快指针走的距离一定是慢指针的两倍，那么假设快指针和慢指针同时进入环（这种情况是可能发生的：一个首尾相连的链表），快指针在走完两圈后，慢指针才走完一圈，正好两个指针在起点相遇，这是最极限的情况。一般情况下，快指针都会比慢指针先进入环，快指针先在环内走，那么肯定的，慢指针在还没走完一圈的时候，快指针就能追上了。

![142环形链表4](https://img-blog.csdnimg.cn/2021031816515727.png)

第二个问题：当然，在你看来，快指针一下跳两个节点，慢指针一下跳一个节点，快指针会不会刚好越过慢指针？这只是相对于你而言。对于慢指针来说，快指针在环内实际上是在以相对1个节点的速度追赶慢指针（慢指针速度为1，那么快指针速度为2，相对慢指针来说快指针就是速度1）。所以快指针不会越过慢指针。

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
            if (slow == fast) {
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2; // 返回环的入口
            }
        }
        return NULL;
    }
};
```



