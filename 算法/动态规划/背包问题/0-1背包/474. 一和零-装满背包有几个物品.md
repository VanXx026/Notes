# 474. 一和零

[474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/)



## 1. 动态规划

这题如果是第一次接触，我估计很难想得到用动态规划做吧，实际上这题不仅是动态规划，而且还是经典的0-1背包问题，但是这题难就难在背包是二维的，不仅仅只有一个“重量”。

来看看这题转化为背包问题是哪四个因素：

1. 背包重量：0的个数m、1的个数n
2. 物品重量：字符串组中的字符串
3. 物品价值：字符串组中的字符串，因为要求的是背包能装最多多少个物品
4. 物品数量：一个字符串就是一个物品

那么这样看来，特殊的就有背包重量这个因素变成二维的以及所求价值了。

现在最大的问题就出在背包重量是二维上，如果背包重量是二维的，那如果再加上物品，那dp数组岂不得搞个三维的才行？实际上如果用之前所说的二维dp来说，现在确实是三维的，你可以想象成xy轴面是背包的二维，而z轴是物品的一维，当然肯定不可能用三维的dp数组，空间太大了。**因此我们会选择使用滚动数组的思路，将三维dp降为二维dp。**

动态规划五步走：

1. 确定dp数组以及含义：

   - **dp[i] [j]：当有i个0和j个1时，可以装下dp[i] [j]个字符串子集。**

2. 确定递推公式

   - **dp[i] [j] = max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1)**
   - zeroNum：当前遍历的字符串中字符0的个数
   - oneNum：当前遍历的字符串中字符1的个数
   - 因为是滚动数组，所以遍历过的上一个字符串留下来的dp[i] [j]状态（也可以说是当前字符串不取时）需要和 装入当前的字符串到背包中的物品个数dp[i - zeroNum] [j - oneNum] + 1 比较，取最大。
   - dp[i] [j]：当前字符串不装入背包时当前背包物品个数
   - dp[i - zeroNum] [j - oneNum] + 1：当前字符串装入背包时当前背包物品个数，因为装入了一个新物品，所以后面跟着+1

3. dp数组初始化

   - 滚动数组一致，都初始化为0即可

4. dp数组遍历顺序：

   - 先遍历物品，再遍历背包

   - 背包遍历和滚动数组一致，二维外层倒序遍历，内层倒序遍历，避免覆盖之前留下来的值

5. 纸上推演dp数组

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0)); // 初始化
        // 遍历物品
        for(string str : strs)
        {
            int zeroNum = 0;
            int oneNum = 0;
            // 记录0和1个数
            for(char c : str)
            {
                if(c == '0') zeroNum++;
                else oneNum++;
            }
            for(int i = m; i>=zeroNum; i--)  // 注意结束循环条件，如果当前背包重量装得下物品才继续遍历
            {
                for(int j = n; j>=oneNum; j--) // 注意结束循环条件，如果当前背包重量装得下物品才继续遍历
                {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

