# 322. 零钱兑换

[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/)



## 1. 动态规划

这题是一个新的题型，首先是完全背包这个没有问题，但是这题有两个问题需要解决：

1. 这题要求的是凑成总金额最少的硬币数，即**装满背包的最小物品数量**
2. 如果现有的硬币面额没有办法凑出总金额，那么返回-1。

首先是第一个问题，不同于之前装满背包的方式只有一种，所以求出数量就行，但零钱是有多种方式凑成总金额的，因此递推公式和初始化的方式都得变化，遍历顺序根据题目性质就是外物品内背包的方式。
递推公式的话，很容易就能想到是dp[j] = min(dp[j], dp[j - coins[i]] + 1)，但是光有这个递推公式还不行，如果初始化按照以前全0的方式，那么这个递推公式是不起作用的，因为都是0，最后取到的最小都会是0，所以初始化除了下标0之外，都需要修改成INT_MAX作为初始值，这样递推公式才会起作用，而下标0仍然为0是因为题目的意思：当总金额为0时，不用任何一个硬币就能凑出来，所以是0。所以这题的初始化方法就是：

```c++
vector<int> dp(amount+1, INT_MAX);
dp[0] = 0;
```

然后是第二个问题，这个问题其实可以另外再用一个dp用于记录能否装满背包来记录硬币面额能否凑出总金额，但是这种方法会用多一倍的空间，显然不是最优解，另外一种办法是做出约束，只有当前硬币可以凑出当前背包容量的时候才能做dp更新操作，如果不能就不能更新当前dp格，这样一来，如果当前硬币没有办法凑出总金额，那么dp[amount]就会一直处于未初始化的状态，即INT_MAX。

代码如下：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 初始化
        vector<int> dp(amount+1, INT_MAX);
        dp[0] = 0;
        for(int i = 0; i<coins.size(); i++)
        {
            for(int j = coins[i]; j<=amount; j++) // 注意起始点，如果容量比硬币小就不用管
            {
                // 如果当前硬币没取之前的金额容量没有凑出来，即还是初始值，那么就没办法使用
                // 换个角度来说就是只有当前硬币可以凑出当前背包容量时才能做dp更新操作
                // 这也就是为什么0需要初始化为0，因为硬币刚好能凑出当前金额时需要用到下标0的dp格
                if(dp[j-coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j-coins[i]]+1);
            }
        }
        // 如果dp[amount] == INT_MAX，说明总金额没有办法凑出来
        if(dp[amount] == INT_MAX) return -1;
        else return dp[amount];
    }
};
```

