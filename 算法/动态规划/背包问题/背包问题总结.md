# 背包问题总结



目前背包问题我们只仔细探究了0-1背包和完全背包，其实两者唯一的区别就是单个物品是否有限，如果只有一个，那么就是0-1背包，如果无限，那么就是完全背包。

## 背包递推公式

背包问题的问法有基本的四种：

1. 装满背包的最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
   - 474.一和零
2. 能否装满背包（或者说最多能装多少）：dp[j] = max(dp[j], dp[j - weight[i]] + weight[i])
   - 416.分割等和子集
   - 1049.最后一块石头的重量Ⅱ
3. 装满背包有多少种方式：dp[j] = dp[j] + dp[j-weight[i]]
   - 494.目标和
   - 518.零钱兑换Ⅱ
   - 377.组合总和Ⅱ
   - 70.爬楼梯进阶版（完全背包）
4. 装满背包最少的物品数：dp[j] = min(dp[j], dp[j - weight[i]] + 1)
   - 322.零钱兑换
   - 279.完全平方数
5. 其他
   - 139.单词划分（其实也算能否装满背包，但是比较另类）



## 遍历顺序

### 1. 0-1背包

如果只是解决0-1背包问题，无论是使用二维dp和一维dp都是比较固定的遍历顺序。

**如果是二维dp，那么外层遍历背包和物品都是可以的，没有区别，我个人比较喜欢外层遍历物品。**

**如果是一维dp，那么就一定是外层顺序遍历物品，内层倒序遍历背包了，倒序遍历是为了防止覆盖旧值。**

### 2. 完全背包

完全背包的二维实现很麻烦，而且如果只是简单的颠倒内外层遍历顺序无法达到求组合数和排列数的效果，无论是外层遍历物品还是背包都只能求组合数，所以完全背包我并不推荐使用二维dp来作为思路。

完全背包完全可以用一维dp来思考，而且在初始化、遍历顺序、递推公式各方面都会简单很多。

**如果是求组合数（无序），外层顺序遍历物品，内层顺序遍历背包。**

**如果是求排列数（有序），外层顺序遍历背包，内层顺序遍历物品。**



## 背包问题的思维导图

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpeg)