# 62. 不同路径

[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/)



## 1. 动态规划

实际上并不困难，和爬楼梯的递推公式思路上差不多，因为最终要算的是最后一个格子的路径，所以只要把沿途中所有的位置的路径条数都算好就可以了。因为每个位置只能从上方和左方的位置到达，所以递推公式中当前位置的路径条数一定和上方位置和左方位置有关。这题因为是二维的dp，所以各方面会和一维的有些区别。

来吧，动态规划五步走

1. 确定dp数组和含义
   - dp[i] [j]：从[0] [0]位置到[i] [j]位置的路径条数dp[i] [j]
2. 确定递推公式
   - dp[i] [j] = dp[i] [j-1] + dp[i-1] [j] , (i >= 1; j>=1)
   - 即上方位置的值 + 左方位置的值
3. 确定初始化
   - 在地图中，比较特殊的是第一行和第一列，因为这两块只能参考其中一个位置得到值（上方或者左方），而且值也很容易确定，因为只能从一个方向走，所以这里的值都为1
4. 确定遍历顺序
   * 不难理解，肯定是左到右，上到下的遍历
5. 纸上模拟

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[m][n];
        // 初始化
        for(int i = 0; i<m; i++) dp[i][0] = 1;
        for(int i = 0; i<n; i++) dp[0][i] = 1;
        // 动态规划
        for(int i = 1; i<m; i++)
        {
            for(int j = 1; j<n; j++)
            {
                dp[i][j] = dp[i][j-1] + dp[i-1][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```

当然，这题是可以优化的，将空间优化为一维数组，思路是这样的：
数组中每个符合递推公式条件的位置都是通过上方以及左方的位置的值得来的，我们不妨将一列的数都用一个位置来保存，因为最终我们只需要最后一个位置的值，所以其他位置的值在遍历过程中被覆盖了也无所谓。

比如3 * 3的格子，那么dp[i]的含义就变成了先容纳dp[0] [i]的值，然后下一行遍历就变成了容纳[1] [i]的值，然后下一行就变成了容纳[2] [i]的值，期间从dp[0] [i] => dp[1] [i] 就可以通过 dp[i] = dp[i] + dp[i-1] 获得。

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        // 优化空间
        int dp[n];
        // 初始化
        for(int i = 0; i<n; i++) dp[i] = 1;
        // 动态规划
        for(int i = 1; i<m; i++)
        {
            for(int j = 1; j<n; j++)
            {
                dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
};
```

