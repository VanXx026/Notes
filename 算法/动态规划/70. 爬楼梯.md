# 70. 爬楼梯

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/)



## 1. 动态规划

一开始看的话，这题还是比较难想到的，但是还是有突破点的，因为爬楼梯一次只能爬1或者2个台阶，比如说如果要到第3阶，你要么从第1阶爬两层到第3阶，要么从第2阶爬一层到第3阶，其他的阶层是爬不到第3阶的，这感觉不就来了么？

第 i 阶台阶只能通过第 i - 1 阶和第 i - 2 阶到达。我们要求到达该层台阶有多少种方法，因为第 i - 1 阶和第 i - 2 阶到达第 i 阶的方法无非都是分别一种（i-1到i爬一层、i-2到i爬两层），那么只要我们得知爬到第 i - 1 阶和第 i - 2 阶有多少种方法，两个值相加，不就可以得到到达第 i 阶的方法数了吗？

感觉上就和斐波那契数很像了。

确定动态规划五步走：

1. 确定dp数组以及下标含义：
   - dp[i]：到第 i 阶有dp[ i ]种方法
2. 确定递推公式：
   - dp[i] = dp[i - 1] + dp[i - 2], i > 2
3. 确定dp数组的初始化：
   - 到达第1阶只有一种办法，dp[1] = 1
   - 到达第2阶有两种办法，dp[2] = 2
4. 确定dp数组遍历顺序：
   - 因为是由前两阶推出，所以是左向右遍历
5. 自己尝试推导一遍

代码如下：

其中需要注意题目中阶层的范围是[1, 45]，所以把下标0空出来就行了，初不初始化不在考虑范围内。

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2)
        {
            return n;
        }
        int dp[n+1]; // 使用[1, n]
        // 初始化
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i<=n; i++)
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

然后是优化空间版：

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2)
        {
            return n;
        }
        // 只使用两个空间：i-2、i-1，[1, 2]
        int dp[3]; 
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i<=n; i++)
        {
            int sum = dp[1] + dp[2];
            // 向前推进
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```



