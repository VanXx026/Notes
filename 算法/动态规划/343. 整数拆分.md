# 343. 整数拆分

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/)



## 1. 动态规划

这题在动态规划的思路上是比较难的，主要是拆分的思路比较难想，因此导致dp数组比较难确定，就更不用说递推公式了。而且就算确定好了dp数组，递推公式也很难确定，如果没有一个正确的思路可能会越搞越复杂。

动态规划其实是比较耿直的一种算法，不用去想怎么样可以最优，怎么样可以减少计算，这些都不需要考虑，你需要的是去考虑题目中有什么规律，递推关系如何就可以了，带着这种朴素的想法，我们想一下拆分到底是怎么拆分的。

论拆分，那么有一个数 i ，如果拆分成两部分的话，那么其中一个数如果拆分为 j ，显然另一个数就是 i - j 了。这只是拆分成了两个数，然而这不一定就是最佳情况了，还有可能拆分成三个及以上的数，那么这时就开始复杂起来了，到底要拆分哪个数？还是说两个数都再次拆分？这时候我们可以举例子来理清思路：
假设现在 i = 10：
前一个数为j，后一个数为i-j
你可以拆分成1 * 9、2 * 8、3 * 7、4 * 6、5 * 5、6 * 4、7 * 3、8 * 2、9 * 1
根据题例，你可以知道，10 = 3 * 3 * 4的时候才最大，所以拆分成两个数是不行的。
我们不妨将j固定，我们只拆分i-j，i - j中我们选择 7 来拆分，7的拆分同样也是拆分两部分：
1 * 6、2 * 5、3 * 4、4 * 3、5 * 2、6 * 1
其中最大的值是3 * 4 和 4 * 3，同为12，那么我们就可以选择这个值。
所以最后10的拆分应该是3 * 3 * 4这个组合。

如果是这样去理清关系的话，就可以意识到有递推关系了，10的两位拆分3 * 7，可以继续往下两位拆分7，进而拆分成3 * 4。意思就是：后面的数字的拆分可以依赖前面已经拆分得到的最大的值，进而得到当前数字的最大值，当然也不是越拆分越好，有时候只拆分成两个也可以达到最大，比如6的3 * 3 = 9，这时候就需要进行比较了。

关于为什么只拆分i - j，不拆分j的问题：首先i 和 i - j 的值是对称的，实际上拆分谁都可以，只是因为这里因为我们遍历的是 j ，如果拆分 j 的话比较混乱，所以拆分i - j。

到这里，我们的分析就结束了，动态规划五步走：

1. 确定dp数组和含义
   - dp[i]：拆分数字i，得到的最大乘积dp[i]
2. 确定递推公式
   - 遍历[1, i]从中选出一个拆分数 j 作为根结点，然后根据两个方式来得到最大乘积dp[i]
   - 方式1：i 只拆分成两个数，即 j * (i - j) 
   - 方式2：将 i - j 继续拆分，即 j * dp[i - j]
   - 比较两种方式得到的最大乘积哪个最大。
   - dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]) )
3. 确定初始化
   - 此时的初始化需要根据题目的数值范围来得到，因为拆分数的范围是大于等于2的，所以0和1我们不用初始化也没有意义去初始化，只需要初始化2
   - dp[2] = 1 * 1 = 1
4. 确定遍历顺序
   * 从左到右
5. 纸上模拟

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1, 0); // 如果使用数组的话会有初始化的问题，所以还是推荐用vector容器
        dp[2] = 1;
        for(int i = 3; i<=n; i++)
        {
            for(int j = 1; j<i; j++)
            {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```

当然，这题可以在时间上进行优化，上面我们在遍历 j 的时候可以看到，中间靠后的拆分组合，拆分i - j都显得没有意义，因为拆分的大头就变成了 j ，而且就算是不继续往下拆分的时候，因为前面和后面的值是一样的，所以在前面遍历的时候就已经可以获取到这个最大值了，所以遍历后面完全没有必要。
1 * 9、2 * 8、3 * 7、4 * 6、5 * 5、**6 * 4、7 * 3、8 * 2、9 * 1**

根据这个思路，我们可以把 j 的遍历范围从[1, i]变为[1, i / 2]，代码如下：

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1, 0);
        dp[2] = 1;
        for(int i = 3; i<=n; i++)
        {
            for(int j = 1; j<=i/2; j++) // 时间优化
            {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```





## 2. 贪心

贪心的做法其实结合了一定的数学推理，结论就是优先拆成多个3，如果剩下的是4，就保留4（1 * 3 没有 2 * 2大）。

为什么是拆成3呢？因为3这个数很特殊，拆成2的话肯定没有拆成3大，拆成4的话就相当于是拆成2，拆成5的话就相当于是拆成2 * 3，总的来说意思就是，3就是拆分的最大单元，只要保证拆分的时候有足够的3（数大于4时），就可以保证拆分得到的数最大，证明的话我不会，但是通过猜想和推理是可以得出这个结论的。

```c++
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        int result = 1;
        while (n > 4) {
            result *= 3;
            n -= 3;
        }
        result *= n;
        return result;
    }
};
```

