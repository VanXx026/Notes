# 96. 不同的二叉搜索树

[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/)



## 1. 动态规划

这题其实如果不是告诉你要用动态规划的话挺困难的，如果没有往这方面想，要意识到二叉树之间的递推关系其实是非常困难的，这题的难点就在于确定递推公式。

当然，在做动态规划的题之前，都必须对题目的条件和情况进行模拟，这题我尝试将2 3 4三种情况都在纸上画出来之后，才发现了规律所在：**两个节点的二叉搜索树有两种；而三个节点的二叉搜索树有五种，其中你可以发现，三个节点的二叉搜索树中，有四颗树都只有一个子树，且这个子树的形状和两个节点的二叉搜索树的形状是一样的。每种形状分别有两颗子树对应。**

<img src="https://img-blog.csdnimg.cn/20210107093106367.png" alt="96.不同的二叉搜索树" style="zoom:50%;" />

<img src="https://img-blog.csdnimg.cn/20210107093129889.png" alt="96.不同的二叉搜索树1" style="zoom:50%;" />

为什么会出现这种情况呢？这是二叉搜索树的性质造成的：左小右大，根据选定的中间节点不同，大体上二叉搜索树的结构是固定的。
比如n=3时：
如果选择根节点为1，因为剩下的节点值都比他大，所以剩下的节点都会在右边组成右子树，此时这颗右子树由两个节点组成，有两种构造方式，即对应了n=2时的情况；
如果选择根节点为2，此时剩下的节点有1和3，那么就分别形成节点个数都为1的左右子树，我们都知道只有一个节点的话那么肯定种类就只有一种了，即对应了n=1时的情况；
如果选择根节点为3，因为剩下的节点值都比他小，所以剩下的节点都会在左边组成左子树，此时这颗左子树由两个节点组成，有两种构造方式，即对应了n=2时的情况。
这样分析之后，思路就很明确了：我们需要遍历[1, n]从中选出一个值作为根结点，然后根据子树的情况来确定一种构造方式的种类。

<img src="https://img-blog.csdnimg.cn/20210107093226241.png" alt="96.不同的二叉搜索树2" style="zoom:50%;" />

那么，动态规划五步走：

1. 确定dp数组和含义
   - dp[i]：以[1, i]为节点值的节点有dp[i]种组成二叉搜索树的方式
2. 确定递推公式
   - 遍历[1, i]从中选出一个节点 j 作为根结点，然后根据子树的情况来确定一种构造方式的种类。
   - dp[i] += dp[j - 1] * dp[i - j]
   - dp[j - 1]，以j为根结点时，左子树节点个数所对应的组成种类数
   - dp[i - j]，以j为根结点时，右子树节点个数所对应的组成种类数
   - 比如：1 2 **3** 4 5，选择j = 3，那么左子树就是1 2，两个；右子树是4 5，两个。
3. 确定初始化
   - 初始化需要将n = 0，和n=1两种情况进行初始化，当然只初始化n = 0也可以
   - dp[0] = 1，按道理来说根结点为空也可以算一棵树
   - dp[1] = 1，左右子树皆为空，即dp[1] = dp[0] * dp[0]，这里也可以得知，如果dp[0] = 0的话递推公式就不成立了
4. 确定遍历顺序
   * 从左到右
5. 纸上模拟

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0); // 注意是n + 1
        // 初始化
        dp[0] = 1;
        dp[1] = 1;
        // 动态规划
        for(int i = 2; i<=n; i++)
        {
            // 递归公式，j为选择的节点
            for(int j = 1; j<=i; j++)
            {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
};
```

还可以进行一定程度的时间优化，因为这题有对称性，比如n = 5，选择n = 1和 n = 5的种类是一样的，同理n = 2 和 n = 4也是，那么遍历其实做一半即到 i / 2 就可以了，然后再根据奇偶性确定是否要加上中间的数即可：

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i<=n; i++)
        {
            for(int j = 1; j<=i/2; j++)
            {
                dp[i] += dp[j-1] * dp[i-j];
            }
            dp[i] = 2 * dp[i];
            // 如果 i 是奇数，即 3 5 7 9等，则需要加上中间的情况
            if(i % 2 != 0)
                dp[i] += dp[(i/2 + 1) - 1] * dp[i - (i/2 + 1)];
        }
        return dp[n];
    }
};
```

