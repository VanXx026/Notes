# 123. 买卖股票的最佳时机Ⅲ

[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)



## 1. 动态规划

这一题的特点是：**股票最多能买卖两次**，单单就是这个条件，就要比121和122难不少，首先如何去限定股票只能买卖两次这个是比较难想的，如果是使用122的思路然后用条件和变量去限定的话，会导致有的情况缺失，很难ac。

在121中，我们说过，买卖股票的dp思路是，将买卖股票时的状态加入到dp数组中，在动态规划时慢慢分析。

而这题我们可以将一天分成四个状态：

1. 第一次持有股票
2. 第一次不持有股票
3. 第二次持有股票
4. 第二次不持有股票

这样的话，虽然空间上确实用的比较多，但是这样思路是更加清晰的，因为买卖两次只是一个限定，可以买卖一次，可以买卖两次，也可以不买卖，如果使用条件限定的话，很容易就把其中一种情况给漏掉了。

递归五步走：

1. 确定dp数组以及下标含义
   - dp[i] [0]：第i天第一次持有股票时的最大利润
   - dp[i] [1]：第i天第一次不持有股票时的最大利润
   - dp[i] [2]：第i天第二次持有股票时的最大利润
   - dp[i] [3]：第i天第二次不持有股票时的最大利润
2. 确定递推公式
   - 第一次持有股票时
     - 第i-1天就有股票，dp[i-1] [0]
     - 第i天第一次买入股票，没有本金，0 - prices[i]
     - 所以dp[i] [0] = max(dp[i-1] [0], -prices[i])
   - 第一次不持有股票时
     - 第i-1天就不持有股票，dp[i-1] [1]
     - 第i天第一次卖出股票，dp[i-1] [0] + prices[i]
     - dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i])
   - 第二次持有股票时
     - 第i-1天就第二次持有股票，dp[i-1] [2]
     - 第i天第二次买入股票，第一次卖出股票的时候还有剩下的金额，dp[i-1] [1] - prices[i]
     - dp[i] [2] = max(dp[i-1] [2], dp[i-1] [1] - prices[i]) 
   - 第二次不持有股票时
     - 第i-1天就第二次不持有股票，dp[i-1] [3]
     - 第i天第二次卖出股票，dp[i-1] [2] + prices[i]
     - dp[i-1] [3] = max(dp[i-1] [3], dp[i-1] [2] + prices[i])
3. 确定初始化
   - 和之前的题目类似，第一行必须初始化
   - 第一次持有，没有本金，所以dp[0] [0] = -prices[0]
   - 第二次持有，你可以理解为第一天买入之后又卖出了，然后第一天第二次买入第一只股票，所以dp[0] [2]也是 - prices[0]
4. 确定遍历顺序
   - 就正常的顺序遍历，没什么好说的
5. 纸上推导

最后答案是dp[prices.size()-1] [3]，你可能会问，如果只卖了一次，那又怎么算呢？在初始化的时候，我们是怎么算第一天第二次持有的值的？我们是假设当天卖了第一只股票然后又在当天买入对吧？那么这里也是同理，如果最终我们只买卖了一只股票，那么我们也可以假设他在同一天买卖了第二只股票，所以这时dp[prices.size()-1] [1] 和 dp[prices.size()-1] [3]的值是一样的。 

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        // 0-第一次持有 1-第一次不持有 2-第二次持有 3-第二次不持有
        dp[0][0] = -prices[0];
        dp[0][2] = -prices[0];
        for(int i = 1; i<prices.size(); i++)
        {
            dp[i][0] = max(dp[i-1][0], 0-prices[i]); // 第一次持有没有本金所以是0-prices[i]
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]); // 第一次不持有说明卖了，所以本金就是第一次持有的金额
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]); 
        }
        return dp[prices.size()-1][3]; // 当然是最后卖第二次的时候会更多
    }
};
```

