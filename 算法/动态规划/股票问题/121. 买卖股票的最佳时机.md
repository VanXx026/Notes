# 121. 买卖股票的最佳时机

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)



## 1. 动态规划

这题的特点是：**只能买一股**，买入和卖出都只有一次，因为不用考虑多次买入卖出，所以只需要尽可能的追求低价格买入，高价格卖出即可。关键的就是，怎么样才能做到呢？

这道题一开始我没有想出来dp数组，思路实在是太狭隘了。和打家劫舍类似，对于题目给出的元素，是有不同状态的操作的，而这时候就可以将这些状态操作来作为构建dp数组的思路。

比如说在打家劫舍中，我们将状态分为了偷与不偷两种状态。

那么在买卖股票中，我们就可以将状态分为持有股票和不持有股票两种状态来考虑
严格来说还可以分成四种状态（因为这题比较简单所以没有必要分成四种，因为这会多花费一倍的空间）：买入时、持有时、卖出时、不持有时；在这题中，我们将买入并入持有时的状态，将卖出并入不持有时的状态。

那么就可以开始递归五步走了，因为是初次的思路，所以写详细一些：

1. 确定dp数组以及下标含义：
   - dp[i] [0]：第i天时**持有股票**所获得的最大利润
   - dp[i] [1]：第i天时**不持有股票**所获得的最大利润
2. 确定递推公式
   - 因为每天都有两种状态，因此需要讨论出每种状态是怎么推导的：
   - 什么情况下会持有股票？
     1. 第i-1天的时候就持有股票，即dp[i-1] [0]
     2. 第i天的时候买入了当天的股票，且因为没有本金，且只能购入一只股票，即 0 - prices[i]，
     3. 那么dp[i] [0]就从这两种状态中求得：dp[i] [0] = max(dp[i-1] [0], -prices[i])
   - 什么情况下会不持有股票？
     1. 第i-1天的时候就不持有股票，即dp[i-1] [1]
     2. 第i天的时候以当天的股票价格卖出，因为i-1天的时候还是持有的，所以当前的利润就是dp[i-1] [0] + prices[i]
     3. dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i])
   - 最后的取值肯定是从不持有股票的状态中得出的，不持有股票意味着卖出了股票，因此才有收益，又因为每过一天，我们就会根据上一天的状态来更新持有和不持有的状态，所以最终我们获取的最大利润，就是dp[prices.size()-1] [1]
3. 确定初始化
   - 因为递推公式中当天的状态需要通过昨天的状态推导出，因此dp数组第一行是必须初始化的。
   - dp数组第一行对应第一天的持有股票和不持有股票的状态
   - 第一天就持有股票，只能是第一天就买入了股票，所以需要花prices[0]的金额来买股票
   - dp[0] [0] = -prices[0]
   - 第一天不持有股票，说明没买，那么什么都不用做。
   - dp[0] [1] = 0
4. 确定遍历顺序
   - 遍历顺序的话就比较简单了，按照天数顺序遍历即可。
5. 纸上推导

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i<prices.size(); i++)
        {
            // 第i天持有股票的情况：1.第i-1天手里就有股票 2.第i天买了 取最赚的情况
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            // 第i天不持有股票的情况：1.第i-1天就不持有 2.第i天卖了 取最赚的情况
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[prices.size()-1][1];
    }
};
```





