# 115. 不同的子序列

[115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/)



## 1. 动态规划

这题就是 392. 判断子序列 的求长序列中的子序列的个数版，就类似于背包问题那种求能不能装满和装满有几种方式的区别，当然区别也不会太大。

动态规划五步走：

1. 确定dp数组和下标含义
   - dp[i] [j]：以[0, i-1]为范围的子串s中出现以[0, j-1]为范围的子串t的个数为dp[i] [j]
2. 确定递推公式
   - 还是分析两种情况
   - s[i-1] == t[j-1]时
     - 这时要看s[i-2]和t[j-2]是什么情况，即dp[i-1] [j-1]，因为dp的含义是个数，所以如果当前这两个字符相等的话，说明上个状态的个数可以继续记录
     - dp[i-1] [j]：以[0, i-2]为范围的子串s中出现以[0, j-1]为范围的子串t的个数为dp[i-1] [j]
     - 为什么还需要dp[i-1] [j]呢？是因为除了dp[i-1] [j-1]时可以参考之外，dp[i-1] [j] 也可以匹配，如果纸上推导了就明白了
     - 比如s = ra，t=ra，此时dp[i] [j]代表的位置是s=ra、t=ra，dp[i-1] [j-1]代表的是s=r、t=r，意思是a之前的两者都匹配了，所以这种可以算到dp[i] [j]上，而dp[i-1] [j]代表的是s=r、t=ra，意思是这时的s也可以匹配的上a之前的t，所以也要算
     - 即dp[i] [j] = dp[i-1] [j-1] + dp[i-1] [j] 
   - s[i-1] != t[j-1]时
     - dp[i-1] [j]：以[0, i-2]为范围的子串s中出现以[0, j-1]为范围的子串t的个数为dp[i-1] [j]
     - 为什么匹配的时候算了，不匹配的时候还是dp[i-1] [j]呢？
     - 这时候情况就和 392. 判断子序和 中的一样了
     - 这时因为当前两个字符已经不匹配了，但是考虑到子序列可以是不连续的，所以就算不匹配，还是要把之前匹配的值记录过来，方便后续两个字符又匹配了，可以拿到之前匹配得到的dp值，刚刚我们也说过了dp[i-1] [j]是什么意思了，所以这里赋值为dp[i-1] [j]是合理的
     - dp[i] [j] = dp[i-1] [j]
3. 确定初始化
   - 我们的dp数组的结构和最长公共子序列是一样的，第一行第一列留空。我们回顾一下我们dp数组的定义：以[0, i-1]为范围的子串s中出现以[0, j-1]为范围的子串t的个数为dp[i] [j]
   - dp[i] [0]的意思就是组合成空字符的方式，那么组合成空字符的方式，必然就只有一种了，就是什么字符也不用，所以dp[i] [0] = 1
   - dp[0] [j]的意思就是主串为空字符，组合成所给子序列[0, j-1]的方式，主串为空，那么怎么样都组成不了子序列了，所以dp[0] [j] = 0
4. 确定遍历顺序
   - 传统的顺序遍历，内外都从1开始
   - 并且s和t字符串可以随意内外反转，但是对应的i和j的下标会颠倒，导致初始化、递推公式、dp数组的含义都有所不同，不过思路是一样的。
5. 纸上推导
   - <img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="115.不同的子序列" style="zoom:50%;" />

我在代码中的写法就是，列为主串，行为子串，和图中正好相反，不过思路是一样的，细节不同而已

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<int>> dp(t.size()+1, vector<int>(s.size()+1, 0));
        for(int i = 0; i<=s.size(); i++)
        {
            dp[0][i] = 1;
        }
        for(int i = 1; i<=t.size(); i++)
        {
            for(int j = i; j<=s.size(); j++)
            {
                if(t[i-1] == s[j-1] && dp[i][j-1] < INT_MAX - dp[i-1][j-1]) // 这里是因为题例有一道会溢出，所以加了个判断
                {
                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        return dp[t.size()][s.size()];
    }
};
```

