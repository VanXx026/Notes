# 300. 最长递增子序列

[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)



## 1. 动态规划

子序列这个东西是真恶心，他是在一个数组里面拆分出来形成的一个序列，只要原本的顺序不变，怎么选都是可以的。
比如说[0 3 1 6 2 2 7]的其中一个子序列可以是[3 6 2 7]。

最长递增子序列就是从数组中选出最长的同时还是递增的子序列。然而麻烦就麻烦在，子序列在数组中可以是不连续的，假设我们的dp数组含义是这样的：dp[i]表示下标到i为止（包括i）的数组序列中最长的递增子序列长度。这样的话，会有一个问题：如果是正常的顺序遍历，当前位置的值和前一个位置的值不一定有关系，只有在前一个位置的值nums[i-1]小于当前位置的值nums[i]才构成递增关系。所以我们没有办法只看dp[i-1]来形成dp[i]的值，这并不完备，因为在位置i之前即 [0, i-1] 这些位置的值都是有可能会比nums[i]要小的，而且要记录下这些比nums[i]小的值的位置是比较麻烦的，因为有可能会存在有多个位置的值都比nums[i]要小，但是它们的dp值又是不一样的，这种情况下除了遍历[0, i-1]取dp最大值之外没有更好的办法了。

动态规划五步走：

1. 确定dp数组和下标含义
   - dp[i]：下标到i为止（包括i）的数组序列中最长的递增子序列长度
2. 确定递推公式
   - if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1)
   - i：当前位置
   - j：[0, i-1]范围内层遍历的位置
   - 意思是，从i之前的多个位置中选出最大的dp[j]，即i之前最长的递增子序列的长度，并且因为当前位置的值nums[i]比nums[j]大，所以递增长度+1，因此为dp[j] + 1
   - 如果nums[i]比nums[j]小，说明不构成递增关系，该位置的dp[j]直接跳过
3. 确定初始化
   - 全初始化为1，dp[0, i] = 1
   - 因为每个位置都可以把自己视为递增子序列的首位，所以长度都是1
4. 确定遍历顺序
   - 因为dp中后面的位置依赖于前面的值，所以是顺序遍历
5. 纸上推导
   - <img src="https://img-blog.csdnimg.cn/20210110170945618.jpg" alt="300.最长上升子序列" style="zoom:50%;" />

最后的结果不一定在dp数组的末尾，因为最长递增子序列不一定会在最后一个位置结束，因此需要维护一个ans来实时的记录最大值。

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int ans = 0;
        for(int i = 1; i<nums.size(); i++)
        {
            for(int j = 0; j<i; j++) // 遍历范围为[0, i-1]
            {
                if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j]+1);
            }
            ans = max(ans, dp[i]); // 比较得出最大值
        }
        return ans;
    }
};
```

