# 1143. 最长公共子序列

[1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/)



## 1. 动态规划

这题就是 718. 最长重复子数组 的子序列版，一涉及到子序列我就觉得好恶心。这题和连续子数组的差别其实不大，差别主要是在于当两个元素不相等时的处理方式上。

动态规划五步走：

1. 确定dp数组以及下标含义
   - dp[i] [j]：[0, i-1]的字符串和[0, j-1]的字符串中**最长公共子序列**的长度
   - 这种定义方法参考 718. 最长重复子数组
2. 确定递推公式
   - 同样，分为相等和不相等两种情况：
   - text1[i-1] == text2[j-1]时
     - dp[i] [j] = dp[i-1] [j-1] + 1
     - 同样是需要参考两个字符串当前位置的前一个位置的情况
   - text1[i-1] != text2[j-1]时
     - 这里的情况就和 718. 最长重复子数组 不同了
     - 因为是求最长公共子序列，不要求连续，所以不相等的时候，也需要把前面的状态给传过来后续使用，否则的话最长子序列的记录值就会断开了。由于子序列的特性，就算当前元素不相等，后面的元素也有可能会相等以延长当前所得子序列的长度
     - dp[i] [j] = max(dp[i-1] [j], dp[i] [j-1])
     - dp[i-1] [j]：[0, i-2]的字符串和[0, j-1]的字符串中最长公共子序列的长度
     - dp[i] [j]：[0, i-1]的字符串和[0, j-2]的字符串中最长公共子序列的长度
     - 因为我们最后的目标是得到当前的dp[i] [j] 即 [0, i-1]的字符串和[0, j-1]的字符串中**最长**公共子序列的长度，因此需要比较这两种状态哪种的值最大。
3. 确定初始化
   - 初始化与 718. 最长重复子数组 相同，因为第一行第一列不代表字符串的元素，因此长度为0
4. 确定遍历顺序
   - 因为dp[i] [j] 依赖于 dp[i-1] [j-1]、dp[i] [j-1]、dp[i-1] [j]
   - 所以一定是从上到下，从左到右的顺序遍历，
   - 当然两个字符串的遍历谁内谁外是随意的，内外遍历下标都从1开始。
5. 纸上推导
   - <img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" alt="1143.最长公共子序列1" style="zoom:50%;" />

因为递推公式的特性，所以对于最长公共子序列的长度是一直随着遍历而更新的，因此最后的结果就在dp数组的右下角。

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size()+1, vector<int>(text2.size()+1, 0));
        for(int i = 1; i<=text1.size(); i++)
        {
            for(int j = 1; j<= text2.size(); j++)
            {
                if(text1[i-1] == text2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```

