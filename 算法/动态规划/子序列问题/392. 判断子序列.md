# 392. 判断子序列

[392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/)



## 1. 动态规划

又是子序列问题，只不过这次是判断一个字符串是不是另一个字符串的子序列，实际上也是变种的最长子序列问题，只不过这次的长度固定了，最后判断dp数组中求出来的长度是不是和这个字符串一样长即可。

当然在细节上和最长子序列问题还是有些不同的。

动态规划五步走：

1. 确定dp数组以及下标含义
   - dp[i] [j]：[0, i-1]的字符串和[0, j-1]的字符串中**最长公共子序列**的长度
2. 确定递推公式
   - 同样是两种情况
   - s[i-1] == t[j-1]时
     - dp[i] [j] = dp[i-1] [j-1] + 1
     - 和最长公共子序列一样
   - s[i-1] != t[j-1]时
     - 注意，s串是子串，也就是更短的那个串
     - 此时两个串不相等，我们仍需将之前状态获得的最长公共子序列长度记录以便使用
     - 一定是dp[i] [j] = dp[i] [j-1]
     - dp[i] [j-1]：[0, i-1]的字符串和[0, j-2]的字符串中最长公共子序列的长度
     - 当前两个字符串不相等，只能说明长串t当前元素与短串s不匹配，不匹配咋办，那就只能参考前一个位置j-2即dp[i] [j-1]的值
     - 为什么这题不需要参考dp[i-1] [j]了？
     - dp[i-1] [j]：[0, i-2]的字符串和[0, j-1]的字符串中最长公共子序列的长度
     - 参考了没用啊，我们是要匹配子串s，所以子串s到当前位置[0, i-1]这段是必须保留的，不能去掉i-1，因此只能参考去掉了j-1位置的长串t
   - <img src="https://img-blog.csdnimg.cn/20210303172354155.jpg" alt="392.判断子序列1" style="zoom:50%;" />
3. 确定初始化
   - 和最长公共子串无区别
4. 确定遍历顺序
   - 和最长公共子串无区别
5. 纸上推导
   - <img src="https://img-blog.csdnimg.cn/2021030317364166.jpg" alt="392.判断子序列2" style="zoom:50%;" />

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size()+1, vector<int>(t.size()+1, 0));
        for(int i = 1; i<=s.size(); i++)
        {
            for(int j = 1; j<=t.size(); j++)
            {
                if(s[i - 1] == t[j - 1])
                {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else
                {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        return dp[s.size()][t.size()] == s.size();
    }
};
```

