# KMP算法 —— 字符串匹配问题

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

所以**如何记录已经匹配的文本内容**，是KMP的重点，也是next数组肩负的重任。



## 什么是前缀表next

![文本串和模式串_KMP](E:\VanSama no note\算法\字符串\文本串和模式串_KMP.gif)

当主串和模式串出现不匹配的时候，退回到已经匹配好的部分后的位置继续向后匹配，而记录这个位置就是前缀表的工作。

实际上前缀表记录的是**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

那么什么是前缀和后缀呢？

**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。

**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

比方说，有一个子串：aabaa，他们的相同前后缀就是：aa**（注意：相同前后缀不是aab，前缀子串和后缀子串的顺序都是从左向右，所以后缀不是从后面往前看得到aab）**



## 为什么要用前缀表

我们接着看这个gif图：

![文本串和模式串_KMP](E:\VanSama no note\算法\字符串\文本串和模式串_KMP.gif)

在文本串的第六个位置字符b和模式串的字符f不匹配，所以这个时候使用前缀表将模式串的指针返回到了模式串第三个字符b的位置。

刚才说过前缀表的工作是记录**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

那么这里前缀表是怎么工作的呢？

**模式串下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

所以前缀表的作用就是告诉我们当前位置不匹配后，回到**已经匹配过（前缀）**的位置重新匹配。



## 如何计算前缀表

还是拿aabaa来举例，最后得到的前缀表是这样的：

![得到的前缀表_KMP](E:\VanSama no note\算法\字符串\得到的前缀表_KMP.png)

注意这里的前缀表的下标的意思是：从下标0到该下标的子串范围，比如说前缀表的下标是5的话，那么判断的子串就是"aabaaf"；如果下标是0，那么判断的子串就是"a"。当主串和模式串不匹配时的位置为模式串的下标 5 ，那么则需要取下标为 4 的前缀表。

下标为0时，长度为前1个字符的子串 "a"，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）

模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

![匹配过程使用前缀表_KMP](E:\VanSama no note\算法\字符串\匹配过程使用前缀表_KMP.gif)



## 前缀表与next数组

很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？

**next数组就可以是前缀表**，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。所以前缀表一般来讲和next数组有区别。

其实**这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

如果使用的是next数组，那么匹配过程如下：

![匹配过程使用next数组_KMP](E:\VanSama no note\算法\字符串\匹配过程使用next数组_KMP.gif)



## 获取next数组

next数组的实现方式有两种，我个人比较倾向于直接用前缀表当next数组（就是不减一，不右移的版本），另外一个就是减一，右移的版本，比较抽象我不太喜欢。

### 直接使用前缀表作为next数组的写法

首先有个问题是需要搞清楚的：

**为什么需要用while？如何理解 j = next[j-1]？**
从整个算法来看，获取子串当前位置（即下标i）的最长前后缀子串长度（即 j ）的方式**并不是**在遍历 i 的时候前后缀都从头开始进行比对，**而是每一次只比对前后缀的尾部字符（s[i] == s[j] ?）**，因为**j 的值不仅表示最长前后缀子串的长度，还是前缀子串尾部字符的下标**。

如果比对成功了，那么 j++ ，意思就是前缀长度 +1 ，然后next[i] = j ，记录这个长度。

如果比对不成功，就要回退，所谓的回退就是 j = next[j-1]。

怎么理解回退要用j = next[j-1]呢。

刚刚说了，j 还是前缀子串尾部字符的下标，现在和后缀尾部字符不匹配，s[j] 就不能作为前缀子串的尾部。next[j-1] 是下标为 j-1 时最长前后缀子串的长度，也记录了 j 上一次的前缀子串尾部字符的下标。

所以 j = next[j-1] 的意思就是 j 回到上一次循环的 j （因为上一次循环总要执行 next[i] = j），得到它的值，随后再进行一次比对。看起来就像缩短前缀子串长度再匹配。 

```c++
void getNext(int* next, string& s) //next是next数组，s是模式串
{   
    //初始化，定义j为0
    int j = 0; //j：当前位置前后缀相等子串的长度
    next[0] = j ;
    //遍历模式串，同时填充next数组
    for(int i = 1; i<s.size(); i++) //从1开始遍历
    {
        while(j>0 && s[j] != s[i]) //当s[j] != s[i]时，说明当前前缀和后缀的尾部字符不相等，j就要往回退直到s[j] == s[i]，最坏的情况下会回退到j=0，这时next[i] = 0，即前后缀的相等子串长度为0，
        {
            j = next[j-1]; //因为j-1，所以循环条件要有j>0防止数组越界。
        }
        if(s[j] == s[i]) //当s[j] == s[i]时，说明当前前缀和后缀的尾部字符相等，那么前后缀相等子串的长度+1
        {
            j++;
        }
        next[i] = j; //记录i之前（包括i）的最长前后缀相等子串长度
    } 
}
```



### 减一，右移的next数组的写法

```c++
void getNext(int* next, string& s)
{
	int j = -1;
    next[0] = j;
    for(int i = 0; i<s.size(); i++)
    {
        while(j>=0 && s[j+1] != s[i]) 
        {
            j = next[j];
        }
        if(s[j+1] == s[i])
        {
            j++;
        }
        next[i] = j;
    }
}
```



## 实现strStr()

[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

KMP算法的核心就是得到next数组，得到next数组之后模式匹配就比较简单了。

观察代码，可以发现，实际上模式匹配中循环内的代码和getNext中的代码非常像，其思想是一样的，注意while代码块和if代码块的执行顺序。

还有需要注意的是：**这里为什么会使用while不用if呢（第34行）？**

因为有时候你不是说返回一次就能够找到相等的字符，你返回的位置只是说明你当前不匹配的字符的后缀和返回的子串的位置的前缀一样而已，并不代表这个位置的字符和主串中的就一样（比如说aabaaf为模式串，主串为aabaaa，那么模式串在f的位置和a不匹配，模式串的指针就会返回到b的位置继续比对，然而b也不和a匹配，只能继续返回，指针这时就会返回到a的位置和主串比对，这个时候才匹配成功）

```c++
class Solution{
public:
    void getNext(int* next, string& s) //next是next数组，s是模式串
	{   
        //初始化，定义j为0
        int j = 0; //j：当前位置前后缀相等子串的长度
        next[0] = j ;
        //遍历模式串，同时填充next数组
        for(int i = 1; i<s.size(); i++) //从1开始遍历
        {
            while(j>0 && s[j] != s[i]) //当s[j] != s[i]时，说明当前前缀和后缀的尾部字符不相等，j就要往回退直到s[j] == s[i]，最坏的情况下会回退到j=0，这时next[i] = 0，即前后缀的相等子串长度为0，
            {
                j = next[j-1]; //因为j-1，所以循环条件要有j>0防止数组越界。
            }
            if(s[j] == s[i]) //当s[j] == s[i]时，说明当前前缀和后缀的尾部字符相等，那么前后缀相等子串的长度+1
            {
                j++;
            }
            next[i] = j; //记录i之前（包括i）的最长前后缀相等子串长度
    	} 
	}
    
    int strStr(string haystack, string needle) 
    {	
        if(needle.size <= 0)
        {
            return 0;
        }
        int next[needle.size()];
    	getNext(next, needle);
        int j = 0; //模式串下标
        for(int i = 0; i<haystack.size(); i++)
        {
            while(j>0 && haystack[i] != needle[j])
            {
                j = next[j-1]; //根据next数组的定义，选择j-1下标的值
            }
            if(haystack[i] == needle[j])
            {
                j++;
            }
            
            if(j == needle.size())
            {
                return (i - needle.size() + 1);
            }
		}
        return -1;
    }
}
```

算法的时间复杂度为O(n+m)。



## 重复的子字符串

[459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

